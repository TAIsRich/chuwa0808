1.  List all of the annotations you learned from class and homework to
    annotaitons.md

2.  Briefly reading: https://www.techgeeknext.com/spring-boot/spring-aop-intervie
    w-questions

3.  What is the Aspect Oriented Programming?
    * In computing, aspect-oriented programming (AOP) is a programming paradigm that aims to increase modularity by allowing the separation of cross-cutting concerns. It does so by adding behavior to existing code (an advice) without modifying the code itself, instead separately specifying which code is modified via a "pointcut" specification, such as "log all function calls when the function's name begins with 'set'". This allows behaviors that are not central to the business logic (such as logging) to be added to a program without cluttering the code core to the functionality.
4.  What are the advantages and disadvantages of Spring AOP?
    * Advantages:
      1. AOP is non-invasive:
         * Service or Domain classes get advice by the aspects (cross-cutting concerns) without adding Spring AOP related classes or interfaces into the service or domain classes.
         * Allows the developers to concentrate on the business logic, instead of the cross-cutting concerns.
      2. AOP is implemented in pure Java:
         * There is no need for a special compilation unit or special class loader
      3. It uses Spring’s IOC container for dependency injection:
         * Aspects can be configured as normal spring beans.
      4. Like any other AOP framework, it weaves cross-cutting concerns into the classes, without making a call to the cross-cutting concerns from those classes.
      5. Centralizes or modularizes the cross-cutting concerns:
         * Easy to maintain and make changes to the aspects.
         * Changes only need to be made in one place.
      6. Provision to create aspects using schema-based (XML configuration) or @AspectJ annotation based style.
      7. Easy to configure.
    * Disadvantages
      1. A small difficulty is debugging the AOP framework-based application code. Since the business classes are advised after the scene with aspects.
      2. Since it uses proxy-based AOP, only method-level advising is supported; it does not support field-level interception. So join-points can be at method level not at field level in a class.
      3. Only methods with public visibility will be advised: Methods with private, protected, or default visibility will not be advised.
      4. There's small runtime overhead, but its negotiable: The overhead is in nano-seconds.
      5. Aspects cannot advise other Aspects - it's not possible to have aspects as targets of advice from other aspects.
         Because once you mark one class as an aspect (either use XML or annotation), Spring excludes it from being auto-proxied.
      6. Local or internal method calls within an advised class don’t get intercepted by proxy, so the advice method of the aspect does not get fired or invoked.
      7. It is not for advising fine-grained objects (or domain objects)—it is best suitable for coarse-grained objects due to performance.
5.  What is Aspect in Spring AOP?
    * Aspect: An aspect is a class that implements enterprise application concerns that cut across multiple classes, such as transaction management. Aspects can be a normal class configured through Spring XML configuration or we can use Spring AspectJ integration to define a class as Aspect using @Aspect annotation.
6.  What is Pointcut in Spring AOP?
    * Pointcut: Pointcut is expressions that are matched with join points to determine whether advice needs to be executed or not. Pointcut uses different kinds of expressions that are matched with the join points and Spring framework uses the AspectJ pointcut expression language.
7. What is the Join point in Spring AOP?
    * Join Point: A join point is a specific point in the application such as method execution, exception handling, changing object variable values, etc. In Spring AOP a join point is always the execution of a method.
8.  What does it mean by Advice and its types in Spring AOP?
    * Based on the execution strategy of advice, they are of the following types:
      1. Before Advice: These advices runs before the execution of join point methods. We can use @Before annotation to mark an advice type as Before advice.
      2. After (finally) Advice: An advice that gets executed after the join point method finishes executing, whether normally or by throwing an exception. We can create after advice using @After annotation.
      3. After Returning Advice: Sometimes we want advice methods to execute only if the join point method executes normally. We can use @AfterReturning annotation to mark a method as after returning advice.
      4. After Throwing Advice: This advice gets executed only when join point method throws exception, we can use it to rollback the transaction declaratively. We use @AfterThrowing annotation for this type of advice.
      5. Around Advice: This is the most important and powerful advice. This advice surrounds the join point method and we can also choose whether to execute the join point method or not. We can write advice code that gets executed before and after the execution of the join point method. It is the responsibility of around advice to invoke the join point method and return values if the method is returning something. We use @Around annotation to create around advice methods.
9.  What is Spring AOP Proxy? https://www.digitalocean.com/community/tutorials/spring-aop-example-tutorial-aspect-advice-pointcut-joinpoint-annotations
    AOP proxy: Spring AOP implementation uses JDK dynamic proxy to create the Proxy classes with target classes and advice invocations, these are called AOP proxy classes. We can also use CGLIB proxy by adding it as the dependency in the Spring AOP project.
10. Briefly Reading: https://www.javainuse.com/spring/sprbatch_interview

11. When to use Spring Batch?
    * Consider an environment where users have to do a lot of batch processing. This will be quite different from a typical web application which has to work 24/7. But in classic environments it's not unusual to do the heavy lifting for example during the night when there are no regular users using your system. Batch processing includes typical tasks like reading and writing to files, transforming data, reading from or writing to databases, create reports, import and export data and things like that. Often these steps have to be chained together or you have to create more complex workflows where you have to define which job steps can be run in parallel or have to be run sequentially etc. That's where a framework like Spring Batch can be very handy. Spring Boot Batch provides reusable functions that are essential in processing large volumes of records, including logging/tracing, transaction management, job processing statistics, job restart, skip, and resource management. It also provides more advanced technical services and features that will enable extremely high-volume and high performance batch jobs though optimization and partitioning techniques.Simple as well as complex, high-volume batch jobs can leverage the framework in a highly scalable manner to process significant volumes of information.
12. How Spring Batch works?
    ![avatar](/1.png)
    1. Step - A Step that delegates to a Job to do its work. This is a great tool for managing dependencies between jobs, and also to modularise complex step logic into something that is testable in isolation. The job is executed with parameters that can be extracted from the step execution, hence this step can also be usefully used as the worker in a parallel or partitioned execution.
    2. ItemReader - Strategy interface for providing the data. Implementations are expected to be stateful and will be called multiple times for each batch, with each call to read() returning a different value and finally returning null when all input data is exhausted. Implementations need not be thread-safe and clients of a ItemReader need to be aware that this is the case. A richer interface (e.g. with a look ahead or peek) is not feasible because we need to support transactions in an asynchronous batch.
    3. ItemProcessor - Interface for item transformation. Given an item as input, this interface provides an extension point which allows for the application of business logic in an item oriented processing scenario. It should be noted that while it's possible to return a different type than the one provided, it's not strictly necessary. Furthermore, returning null indicates that the item should not be continued to be processed.
    4. ItemStreamWriter - Basic interface for generic output operations. Class implementing this interface will be responsible for serializing objects as necessary. Generally, it is responsibility of implementing class to decide which technology to use for mapping and how it should be configured. The write method is responsible for making sure that any internal buffers are flushed. If a transaction is active it will also usually be necessary to discard the output on a subsequent rollback. The resource to which the writer is sending data should normally be able to handle this itself.
13. How can we schedule a Spring Batch Job?
    * Spring Batch can be scheduled using Cron Job.
