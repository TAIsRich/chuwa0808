## hw16

### 1. What is Automation Testing?
- a software testing technique that performs using special automated testing software tools to execute a test case suite
- automation testing software can also enter test data into the System Under Test, compare expected and actual results, and generate detailed test reports
- Manual Testing is performed by a human sitting in front of a computer carefully executing the test steps

### 2. What is selenium(YouTube)?
Selenium:
- a free (open-source) automated testing framework used to validate web applications across different browsers and platforms
- can use multiple programming languages like Java, C#, Python etc. to create Selenium Test Scripts
- Testing done using the Selenium testing tool is usually referred to as Selenium Testing

Selenium Software is not just a single tool but a suite of software, each piece catering to different Selenium QA testing needs of an organization. Here is the list of tools: 
- Selenium Integrated Development Environment (IDE)
- Selenium Remote Control (RC)
- WebDriver
- Selenium Grid

[Selenium](./Selenium.png)

[Video1](https://www.guru99.com/introduction-to-selenium.html)

[Video2](https://www.youtube.com/watch?v=d56lRIAwQEI)

[Video3](https://www.youtube.com/watch?v=4e9vhX7ZuCw&list=PLhW3qG5bs-L_mFHirOLEYJ7X2rIXu8SR2)

### 3. What is cucumber(YouTube)?
- a testing tool that supports Behavior Driven Development (BDD)
- offer a way to write tests that anybody can understand, regardless of their technical knowledge
- in BDD, users (business analysts, product owners) first write scenarios or acceptance tests that describe the behavior of the system from the customer’s perspective, for review and sign-off by the product owners before developers write their codes 
- Cucumber framework uses Ruby programming language

[Video1](https://www.youtube.com/watch?v=d56lRIAwQEI)

[Video2](https://www.youtube.com/watch?v=4e9vhX7ZuCw&list=PLhW3qG5bs-L_mFHirOLEYJ7X2rIXu8SR2)

### 4. What is JMeter(YouTube)?
- JMeter Load Testing is a testing process done using a load testing tool named Apache JMeter which is an open source desktop application based on Java.
- JMeter for load testing is a crucial tool that determines whether the web application under test can satisfy high load requirements or not. It also helps to analyse overall server under heavy load.

[Video1](https://www.youtube.com/watch?v=mXGcBvWYl-U)

[Video2](https://www.youtube.com/watch?v=SoW2pBak1_Q)

### 5. What is Unit Testing and what is Integration Testing?
**Unit testing**:
- a software testing technique, not only used in Java
- test each individual unit/component of an application in isolation, without any interaction with dependencies
- a unit may be an individual function, method, procedure, module or object
- validate that each unit of the software code performs as expected
- can associate with Mockito framework or other Mocking frameworks
- is done during development of an application by the developers
- whitebox test: need to use Mocking/PowerMocking to mock the dependent methods' behaviors

**Integration testing**:
- a software testing technique, not only used in Java
- check if different modules are working fine when they are combined as a group
- need to create real objects/instances and use real data
- usually, integration testing comes right after unit testing to ensure all units operate in harmony with each other
- oftentimes, a unit will be seen as functional on its own but may cause issues when interacting with other units, that is why software testing is so important, especially testing units as a group
- blackbox test: run the real methods, no Mocking/PowerMocking

### 6. What is Junit? 
**Junit**:
- one of the unit testing frameworks
- an open-source testing framework for java programmers
- the java programmers can create test cases and test their own code

### 7. What is the life circle of Junit?
Junit lifecycle is driven by four primary annotations @BeforeAll, @BeforeEach, @AfterEach and @AfterAll. Along with it, each test method must be marked with @Test annotation from package org.junit.jupiter.api.

1. Test Lifecycle Phases: [Junit LifeCycle](./junit_lifecycle.png)

Setup: 
- In this phase, put the test infrastructure in place. 
- JUnit provides class level (static) setup (@BeforeAll) and method level setup (@BeforeEach). 
- Generally, heavy objects like the database connections are created in class level (static) setup, lightweight objects like test objects are reset in the method level setup.

Test Execution: 
- In this phase, the test execution and assertion happen. 
- The execution result will signify a success or failure.

Cleanup: 
- In this phase, cleanup the test infrastructure setup in the first phase. 
- Just like setup, teardown also happen at class level (static, @AfterAll) and method level (@AfterEach).

2. Before And After Annotations:
In the test life cycle, we will primarily need some annotated methods to setup and cleanup the test environment or test data on which the tests run.
- In JUnit, by default, for each test method, a new instance of test is created, which maintains testing each method independent and no interaction between any two methods to be tested.
- @BeforeAll and @AfterAll annotations, clear by their names, should be called **only once** in the entire tests execution cycle. So they must be declared **static**.
- @BeforeEach and @AfterEach are invoked for **each instance** of test, so they should **not be static**.
- For each time, the order to test the methods is random. After Junit 5, we can use annotation @Order to specify the execution order of the methods to be tested.
- If there are multiple methods annotated with the same annotation (e.g. two methods with @BeforeAll), then their execution order is not determined.
```
public class AppTest {

	@BeforeAll
	static void setup(){
		System.out.println("@BeforeAll executed");
	}

	@BeforeEach
	void setupThis(){
		System.out.println("@BeforeEach executed");
	}

	@Test
    void testCalcOne() {
		System.out.println("======TEST ONE EXECUTED=======");
		Assertions.assertEquals( 4 , Calculator.add(2, 2));
    }

    @Test
    void testCalcTwo() {
        System.out.println("======TEST TWO EXECUTED=======");
        Assertions.assertEquals( 6 , Calculator.add(2, 4));
    }

	@AfterEach
	void tearThis(){
		System.out.println("@AfterEach executed");
	}

	@AfterAll
	static void tear(){
		System.out.println("@AfterAll executed");
	}
}
```
```
@BeforeAll executed

@BeforeEach executed
======TEST ONE EXECUTED=======
@AfterEach executed

@BeforeEach executed
======TEST TWO EXECUTED=======
@AfterEach executed

@AfterAll executed
```

3. Disabling Tests:
- To disable a test in JUnit 5, you will need to use @Disabled annotation. 
- It is equivalent to JUnit 4’s @Ignored annotation.
- @Disabled annotation can be applied over **test class** (disables all test methods in that class) or **individual test methods** as well.
```
@Disabled
@Test
void testCalcTwo()
{
	System.out.println("======TEST TWO EXECUTED=======");
	Assertions.assertEquals( 6 , Calculator.add(2, 4));
}
```

4. Assertions:
- In any test method, we will need to determine whether it passes or fails. We can do it using Assertions.
- Assertions help in validating the expected output with the actual output of a test. 
- To keep things simple, all JUnit Jupiter assertions are static methods in the org.junit.jupiter.Assertions class.
```
@Test
public void test() 
{
    //Test will pass
    Assertions.assertEquals(4, Calculator.add(2, 2));
      
    //Test will fail 
    Assertions.assertEquals(3, Calculator.add(2, 2), "Calculator.add(2, 2) test failed");
      
    //Test will fail 
    Supplier<String> messageSupplier  = ()-> "Calculator.add(2, 2) test failed";
    Assertions.assertEquals(3, Calculator.add(2, 2), messageSupplier);
}
```
```
@Test
void testCase() {
    Assertions.fail("not found good reason to pass");
}
```

5. Assumptions:
- Assumptions provide static methods to support conditional test execution based on assumptions. 
- A failed assumption results in a test being aborted.
- Assumptions are typically used whenever it does not make sense to continue the execution of a given test method. 
- In the test report, these tests will be marked as passed.
- Assumptions class has three methods with many overloaded forms:

assumeFalse(): validate the given assumption to be false
assumeTrue(): validate the given assumption to be true
assumingThat(): execute the supplied Executable, but only if the supplied assumption is valid
```
@Test
void testOnDev()
{
    System.setProperty("ENV", "DEV");
    Assumptions.assumeTrue("DEV".equals(System.getProperty("ENV")));
    //remainder of test will proceed
}

@Test
void testOnProd()
{
    System.setProperty("ENV", "PROD");
    Assumptions.assumeTrue("DEV".equals(System.getProperty("ENV")));
    //remainder of test will be aborted
}
```

### 8. Should @BeforeAll method be in class level (static)?
- @BeforeAll and @AfterAll annotations, clear by their names, should be called **only once** in the entire tests execution cycle. So they must be declared **static**.
- Generally, heavy objects like the database connections are created in class level (static) setup, lightweight objects like test objects are reset in the method level setup.

### 9. What is Mocking?
**Mocking**:
- a software testing technique, not only used in Java but also used in any object-oriented programming language
- mock objects are used instead of real objects for testing purposes
- mock objects provide a specific (dummy) output for a particular (dummy) input passed to it

To mock objects, you need to understand the **three key concepts** of mocking: **stub**, **fake**, and **mock**. Some unit tests involve **only stubs**, whereas some involve **fakes and mocks**.
**Stub**: 
- Stub objects hold predefined data and provide it to answer the calls during testing. 
- They are referred to as a dummy object with a minimum number of methods required for a test. 
- It also provides methods to verify other methods used to access the internal state of a stub, when necessary. 
- Stub object is generally used for state verification.

**Fake**: 
- Fake objects contain working implementations but are different from the production one. 
- Mostly, it takes shortcuts and also contains the simplified version of the production code.

**Mock**: 
- Mock objects act as a dummy or clone of the real object in testing. 
- They are generally created by an open-source library or a mocking framework like Mockito, EasyMock, etc. 
- Mock objects are typically used for behavior verification.

### 10. What is Mockito? What are Mockito's benefits and limitations? What is PowerMocking and PowerMockito? 
**Mockito**:
- one of mocking frameworks
- a most popular (Java-based) mocking framework in Java
- used for unit testing of Java application, we can use Mockito with some unit testing frameworks like JUnit and TestNG
- play a crucial role in developing testable applications
- internally use the Java Reflection API to generate mock objects for a specific interface
- mock objects are referred to as the dummy or proxy objects used for actual implementations
- main purpose of using the Mockito framework is to simplify the development of a test by mocking external dependencies and use them in the test code
- as a result, it provides a simpler test code that is easier to read, understand, and modify

Mockito's Benefits: [Mockito's Benefits](./mockito_benefits.png)
- no handwriting: no requirement for writing your mock objects
- annotation support: create mock objects using annotations like @Mock
- order support: provide a check on the order of the method calls
- safe refactoring: while renaming the method name of an interface or interchanging the parameters, do not change the test code, as mock objects are created at runtime
- exception support: support the exceptions, and the stack trace is used to find the cause of an exception

Mockito's limitations:
- cannot mock constructors, final, static or private methods
- cannot mock equals(), hashCode() methods
- require Java version 6 plus to run
- VM mocking is only possible on VMs that are supported by Objenesis

**PowerMocking**:
- Unit testing with the help of a mocking framework has been recognized as a useful practice for a long time, and the Mockito framework in particular has dominated this market in recent years.
- In order to facilitate decent code designs and make the public API simple, some desired features have been intentionally left out. In some cases, however, these shortcomings force testers to write cumbersome code just to make the creation of mocks feasible.
- This is where the PowerMocking framework comes into play.

**PowerMockito**:
- PowerMockito is a PowerMock's extension API to support Mockito.
- It provides capabilities to work with the Java Reflection API in a simple way to overcome the problems of Mockito, such as the lack of ability to mock constructors, final class, and final, static or private methods.
```
模拟final类或final方法：

@Getter
@Setter
@ToString
public final class Circle {
    private double radius;
    public double getArea() {
        return Math.PI * Math.pow(radius, 2);
    }
}

@RunWith(PowerMockRunner.class)
@PrepareForTest({Circle.class})
public class CircleTest {
    @Test
    public void testGetArea() {
        double expectArea = 3.14D;
        Circle circle = PowerMockito.mock(Circle.class);
        PowerMockito.when(circle.getArea()).thenReturn(expectArea);
        double actualArea = circle.getArea();
        Assert.assertEquals("返回值不相等", expectArea, actualArea, 1E-6D);
    }
}
```
```
用途：可以用于模拟类的静态方法，必须使用annotation @RunWith and @PrepareForTest

@RunWith(PowerMockRunner.class)
@PrepareForTest({StringUtils.class})
public class StringUtilsTest {
    @Test
    public void testIsEmpty() {
        String string = "abc";
        boolean expected = true;
        PowerMockito.mockStatic(StringUtils.class);
        PowerMockito.when(StringUtils.isEmpty(string)).thenReturn(expected);
        boolean actual = StringUtils.isEmpty(string);
        Assert.assertEquals("返回值不相等", expected, actual);
    }
}
```

### 11. What is @Mock? What is Mockito.mock()? How to use them?
**Mockito.mock()**:
- The Mockito.mock() method allows us to create a mock object of a class or an interface.
- We can then use the mock to stub return values for its methods, and verify if they were called.
- We can use it to create mock class fields, as well as local mocks in a method.
- We do not need to do anything else to this method before we can use it.
```
@Test
public void givenCountMethodMocked_WhenCountInvoked_ThenMockedValueReturned() {
UserRepository localMockRepository = Mockito.mock(UserRepository.class);
Mockito.when(localMockRepository.count()).thenReturn(111L);

    long userCount = localMockRepository.count();

    Assert.assertEquals(111L, userCount);
    Mockito.verify(localMockRepository).count();
}
```
```
public class EmployeeServiceImplTest {

    private EmployeeRepository employeeRepository;
    private EmployeeService employeeService;

    @BeforeEach
    void setUp() {
        employeeRepository = Mockito.mock(EmployeeRepository.class);
        employeeService = new EmployeeServiceImpl(employeeRepository);
    }

    // test...
```

**Mockito's @Mock Annotation**:
- This annotation is a shorthand for the Mockito.mock() method.
- We should only use it in a test class.
- In JUnit 4, use @RunWith(MockitoJUnitRunner.class) or Mockito.initMocks(this) to initialize these mocks and inject them.
- In JUnit 5, use @ExtendWith(MockitoExtension.class) to initialize these mocks and inject them.
- Unlike the mock() method, we need to enable Mockito annotations to use this annotation.
```
// @RunWith(MockitoJUnitRunner.class) // JUnit 4
@ExtendWith(MockitoExtension.class) // JUnit 5
public class MockAnnotationUnitTest {

    @Mock
    UserRepository mockRepository;
    
    @Test
    public void givenCountMethodMocked_WhenCountInvoked_ThenMockValueReturned() {
        Mockito.when(mockRepository.count()).thenReturn(123L);

        long userCount = mockRepository.count();

        Assert.assertEquals(123L, userCount);
        Mockito.verify(mockRepository).count();
    }
}
```

Apart from making the code more readable, @Mock makes it easier to find the problem mock in case of a failure, as the name of the field appears in the failure message:
```
Wanted but not invoked:
mockRepository.count();
-> at org.baeldung.MockAnnotationTest.testMockAnnotation(MockAnnotationTest.java:22)
Actually, there were zero interactions with this mock.

at org.baeldung.MockAnnotationTest.testMockAnnotation(MockAnnotationTest.java:22)
```
Furthermore, when @Mock is used in conjunction with @InjectMocks, it can reduce the amount of setup code significantly.

### 12. What is the difference between @Mock and @InjectMocks? How to use them?
- @Mock creates a mock object. 
- @InjectMocks creates an actual instance of the class, and injects the mocks that are created with the @Mock (or @Spy) annotations into this instance.
- In JUnit 4, use @RunWith(MockitoJUnitRunner.class) or Mockito.initMocks(this) to initialize these mocks and inject them.
- In JUnit 5, use @ExtendWith(MockitoExtension.class) to initialize these mocks and inject them.
```
// @RunWith(MockitoJUnitRunner.class) // JUnit 4
@ExtendWith(MockitoExtension.class) // JUnit 5
public class SomeManagerTest {
    @Mock
    private SomeDependency someDependency; // this will be injected into someManager

    @InjectMocks
    private SomeManager someManager;

    // tests...
}
```

### 13. What is stubbing?
#### https://www.youtube.com/watch?v=OWP3bQIMHY8
- One of the primary benefit of Mockito is able to return a provided response when a specific method is called on mocked dependency.
- The process of writing how a given mock method should behave is called stubbing.

The feature is performed in two ways: 
- Using Mockito's static method **when() + thenReturn()**, which states 'when' a specific method is called on the mock object, 'then return' a preconfigured value.
- Using Mockito's static method **doReturn() + when()**, which states 'do return' a preconfigured value, 'when' a specific method is called on the mock object.

### 14. What is the difference between @Spy and @Mock?
**Mock**:
- When Mockito creates a mock, it does so from the Class of a Type, but not from an actual instance.
- The mock simply creates a bare-bones shell instance of the Class, entirely instrumented to track interactions with it.
- The real normal methods called on the mock object does not actually work.
- The stubbed method specified with when() and thenReturn() called on the mock object will return a provided value.
```
adding an element into the mocked list does not actually add anything,
it just calls the method with no other side effects:

@Test
public void whenCreateMock_thenCreated() {
    List mockedList = Mockito.mock(ArrayList.class);

    mockedList.add("one");
    Mockito.verify(mockedList).add("one");

    assertThat(mockedList).hasSize(0);
}
```
```
a specific method called on the mock object in stubbing actually works;
other real methods on the mock object does not actually work in Mockito:

@Mock
private EmployeeRepository employeeRepository;

@Test
public void testSaveEmployee() {

    //given - precondition or setup
    given(employeeRepository.findByEmail(employee.getEmail()))
            .willReturn(Optional.empty());
    given(employeeRepository.save(employee))
            .willReturn(employee);

    System.out.println(employeeRepository);
    System.out.println(employeeService);

    // when - action or the behaviour that we are going test
    Employee savedEmployee = employeeService.saveEmployee(employee);

    System.out.println(savedEmployee);

    // then - verify the output
    Assertions.assertThat(savedEmployee).isNotNull();
}
```

**Spy**:
- When Mockito creates a spy, it will wrap a real object and spies this object.
- The only difference is that it will also be instrumented to track all the interactions with it.
- It will still behave in the same way as a real normal object.
- We can configure/override the behavior of a specific method using the same syntax used with a mock object. Then the spy executes the stubbed method as a mock object.
```
it will actually call the real implementation of the add method,
and add the element to the underlying list:

@Spy
List<String> spyList = new ArrayList<String>();

@Test
public void whenUsingTheSpyAnnotation_thenObjectIsSpied() {
    spyList.add("one");
    spyList.add("two");

    Mockito.verify(spyList).add("one");
    Mockito.verify(spyList).add("two");

    assertThat(aSpyList).hasSize(2);
}
```
```
a specific method called on a spy object in stubbing works like called on a mock object in stubbing;
other real normal methods called on a spy object works like called on a real object:

   List list = new LinkedList();
   List spy = Mockito.spy(list);
   // List spy = Mockito.spy(List.class);
   // List spy = Mockito.spy(LinkedList.class);

   //optionally, you can stub out some methods:
   when(spy.size()).thenReturn(100);

   //using the spy calls *real* methods
   spy.add("one");
   spy.add("two");

   //prints "one" - the first element of a list
   System.out.println(spy.get(0));

   //size() method was stubbed - 100 is printed
   System.out.println(spy.size());

   //optionally, you can verify
   verify(spy).add("one");
   verify(spy).add("two");
```

### 15. What are Mockito ArgumentMatchers?
We need to add a single artifact:
```
<dependency>
    <groupId>org.mockito</groupId> 
    <artifactId>mockito-core</artifactId>
    <version>2.21.0</version> 
    <scope>test</scope>
</dependency>

```

We can configure a mocked method in various ways. One option is to return a fixed value. The String "Flower" is returned only when the analyze service receives the String "poppy".
```
doReturn("Flower").when(flowerService).analyze("poppy");
```

But there may be a case where we need to respond to a wider range of values or unknown values.

In these scenarios, we can configure our mocked methods with argument matchers:
```
when(flowerService.analyze(anyString())).thenReturn("Flower");
```
Now, because of the anyString argument matcher, the result will be the same no matter what value we pass to analyze. ArgumentMatchers allow us flexible verification or stubbing.

**Argument Matcher**:
- anyString
- anyInt
- anyLong
- anyObject
- any(clazz) 
- anyCollection 
- anyCollectionOf(clazz) 
- anyList(Map, Set) 
- anyListOf(clazz)

**Note Points**:
- If a method has more than one argument, we can't just use ArgumentMatchers for only some ones of the arguments. Mockito requires that we provide all arguments either by matchers or exact values.
```
Here we can see an example of an incorrect approach:

when(flowerService.isABigFlower("poppy", anyInt())).thenReturn(true);

To fix this and keep the String name “poppy” as desired, we'll use eq matcher:

when(flowerService.isABigFlower(eq("poppy"), anyInt())).thenReturn(true);
```
- We cannot use them as a return value, we require an exact value when stubbing calls.
- We cannot use argument matchers outside of verification or stubbing.

### 16. What are Hamcrest Matchers?
- Hamcrest is a framework used for writing customized assertion matchers in the Java programming language.
- Hamcrest allows the match rules to be defined declaratively, which makes it valuable in UI validation, data filtering, writing flexible tests, etc.
- Hamcrest Matchers can be used with mock objects by using adaptors.
- Hamcrest Matchers can be used with JUnit and TestNG.








