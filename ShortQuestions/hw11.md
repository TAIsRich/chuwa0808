### 1. List all of the annotations you learned from class and homework to annotation.md
### 2. What is hibernate Caching?
- Hibernate is an ORM (Object-relational model) tool that is widely used by developers worldwide. It has many in-built features available that make the developer’s life simple. One of them is a caching mechanism.
- Hibernate caching acts as a layer between the actual database and your application. It reduces the time taken to obtain the required data — as it fetches from memory instead of directly hitting the database. It is very useful when you need to fetch the same kind of data multiple times.
- Where the cache is stored: In the Hibernate session is the hibernate’s first-level cache and SessionFactory is a second-level cache. So both (session/session-factory) are objects in a heap area. That means the cache is stored in the RAM only. And because of that, it gives faster access to data rather than databases.
### 3. What is the difference between first-level cache and second-level cache?
- 1). First level cache
    - The First level cache is by default enabled by Hibernate itself. The session object maintains the first-level cache.
    - when you query an entity or object, for the very first time it is retrieved from the database and stored into the first-level cache (associated with the hibernate session). If we query for the same entity or object again with the same session object, it will be loaded from cache and no SQL query will be executed. Take a look at the below code snippet.
  ```
    // Open hibernate session
    Session session = HibernateUtil.getSessionFactory().openSession();
    session.beginTransaction();

    // Fetch an Employee entity from the database very first time
    Employee employee = (Employee) session.load(Employee.class, empId);
    System.out.println("First call output : " + employee.getName());

    // Request for Employee entity again
    employee = (Employee) session.load(Employee.class, empId);
    System.out.println("Second call output : "employee.getName());
    
    session.getTransaction().commit();
    HibernateUtil.shutdown();
  
   
    // Output:
    // First call output : John Doe
    // Second call output : John Doe
  ```
    - Some useful methods:
        - Session.evict(): to remove the cached/stored entity.
        - refresh(): method to refresh the cache.
        - clear(): method to remove all the entities from the cache.
    - Note: You can not disable the first-level cache, it is enabled by the hibernate itself. Hibernate entities or database rows remain in cache only until Session is open, once Session is closed, all associated cached data is removed.
2) Second level cache
    - The second-level cache is by default disabled, the developer needs to enable it explicitly, and the SessionFactory object is responsible to maintain it. The second-level cache is accessible by the entire application means data hold by SessionFactory can be accessible to all the sessions. Keep in mind that, once the session factory is closed all the cache associated with that is also removed from the memory.

    - Let’s take an example: Suppose your application has 2 active sessions session1 and session2 respectively. Now, session1 has requested data having id=101 so that will be fetched from a database as it is the first call, and then it is stored into the second-level (SessionFactory) as well as in the first-level (session) cache also. Now, session2 requires the same data so it has also been queried with the same id=101. So this time session2 will get data from the SessionFactory, it will not going to hit the database. Take a look at the below code snippet.
    ```
    // Open hibernate session
    Session session = HibernateUtil.getSessionFactory().openSession();
    session.beginTransaction();
    
    // Employee entity is fecthed very first time (It will be cached in both first-level and second-level cache)
    Employee employee = (Employee) session.load(Employee.class, empId);
    System.out.println(employee.getName());
    
    // Fetch the employee entity again
    employee = (Employee) session.load(Employee.class, empId);
    System.out.println(employee.getName()); //It will return from the first-level
    
    // Evict from first level cache (That will remove employee object from first-level cache)
    session.evict(employee);
    
    // Fetch same entity again using same session
    employee = (Employee) session.load(Employee.class, empId);
    System.out.println(employee.getName()); //It will return from the second-level
    
    // Fetch same entity again using another session
    employee = (Employee) anotherSession.load(Employee.class, empId);
    System.out.println(employee.getName());//It will return from the second-level
    
    System.out.println("Response from the first-level : " + HibernateUtil.getSessionFactory().getStatistics().getEntityFetchCount());
    System.out.println("Response from the second-level : " + HibernateUtil.getSessionFactory().getStatistics().getSecondLevelCacheHitCount());
    
    // Output:
    // Response from the first-level : 1
    // Response from the second-level : 2
    ```

    - When hibernate session try to load an entity, it will first find into the first-level cache, if it does not found then it will look into the second-level cache and return the response (if available), but before returning the response it will store that object/data into first-level also so next time no need to come at the session-level. When data is not found in the second level then it will go to the database to fetch data. Before returning a response to the user it will store that object/data into both levels of cache so next time it will be available at cache stages only.
    - Note: Hibernate does not provide any default implementation for the second-level cache. It gives CacheProvider interface, so any third party Cache which implements CacheProvider interface can be hooked as Second level cache, like EHCache or NCache.

### 4. How do you understand @Transactional?
- Spring provides Declarative Transaction Management via @Transactional annotation. When a method is applied with @Transactional, then it will execute inside a database transaction. @Transactional annotation can be applied at the class level also, in that case, all methods of that class will be executed inside a database transaction.
  Spring provides Declarative Transaction Management via @Transactional annotation. When a method is applied with @Transactional, then it will execute inside a database transaction. @Transactional annotation can be applied at the class level also, in that case, all methods of that class will be executed inside a database transaction.


- How @Transactional works: When @Transactional annotation is detected by Spring, then it creates a proxy[^1] object around the actual bean object. So, whenever the method annotated with @Transactional is called, the request first comes to the proxy object and this proxy object invokes the same method on the target bean. These proxy objects can be supplied with interceptors. Spring creates a TransactionInterceptor and passes it to the generated proxy object. So, when the @Transactional annotated method is called, it gets called on the proxy object first, which in turn invokes the TransactionInterceptor that begins a transaction. Then the proxy object calls the actual method of the target bean. When the method finishes, the TransactionInterceptor commits/rollbacks the transaction.


- One thing to remember here is that the Spring wraps the bean in the proxy, the bean has no knowledge of it. So, only the external calls go through the proxy. As for the internal calls (@Transactional method calling the same bean method), they are called using ‘this’.
  Using @Transactional annotation, the transaction’s propagation and isolation can be set directly, like:


  
### 5. How do you handle the exception in Spring?
1. the Controller-Level @ExceptionHandler[^2]
   - The first solution works at the @Controller level. We will define a method to handle exceptions and annotate that with @ExceptionHandler:
      ```
        public class FooController{
        
        //...
        @ExceptionHandler({ CustomException1.class, CustomException2.class })
           public void handleException() {
                    ....
           }
        }
      ```
   - This approach has a major drawback: The @ExceptionHandler annotated method is only active for that particular Controller, not globally for the entire application. Of course, adding this to every controller makes it not well suited for a general exception handling mechanism.

   - We can work around this limitation by having all Controllers extend a Base Controller class.

   - However, this solution can be a problem for applications where, for whatever reason, that isn't possible. For example, the Controllers may already extend from another base class, which may be in another jar or not directly modifiable, or may themselves not be directly modifiable.

2. the HandlerExceptionResolver
   - The second solution is to define an HandlerExceptionResolver. This will resolve any exception thrown by the application. It will also allow us to implement a uniform exception handling mechanism in our REST AP
   - ExceptionHandlerExceptionResolver: This resolver was introduced in Spring 3.1 and is enabled by default in the DispatcherServlet. This is actually the core component of how the @ExceptionHandler mechanism presented earlier works
   - DefaultHandlerExceptionResolver: It's used to resolve standard Spring exceptions to their corresponding HTTP Status Codes, namely Client error 4xx and Server error 5xx status codes. Here's the full list of the Spring Exceptions it handles and how they map to status codes.
   - ResponseStatusExceptionResolver: This resolver was also introduced in Spring 3.0 and is enabled by default in the DispatcherServlet. Its main responsibility is to use the @ResponseStatus annotation available on custom exceptions and to map these exceptions to HTTP status codes.
```
@ResponseStatus(value = HttpStatus.NOT_FOUND)
public class MyResourceNotFoundException extends RuntimeException {
    public MyResourceNotFoundException() {
        super();
    }
    public MyResourceNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
    public MyResourceNotFoundException(String message) {
        super(message);
    }
    public MyResourceNotFoundException(Throwable cause) {
        super(cause);
    }
}        
```
### 6. How do you do the validations in Spring
- Bean Validation works by defining constraints to the fields of a class by annotating them with certain annotations.
- Common Validation Annotations:
  - @NotNull: to say that a field must not be null.
  - @NotEmpty: to say that a list field must not empty.
  - @NotBlank: to say that a string field must not be the empty string (i.e. it must have at least one character).
  - @Min and @Max: to say that a numerical field is only valid when it’s value is above or below a certain value.
  - @Pattern: to say that a string field is only valid when it matches a certain regular expression.
  - @Email: to say that a string field must be a valid email address.
```
class Customer {

  @Email
  private String email;

  @NotBlank
  private String name;
  
  // ...
}
```
- @Validated and @Valid
    - In many cases, however, Spring does the validation for us. We don’t even need to create a validator object ourselves. Instead, we can let Spring know that we want to have a certain object validated. This works by using the the @Validated and @Valid annotations.
    - The @Validated annotation is a class-level annotation that we can use to tell Spring to validate parameters that are passed into a method of the annotated class.
    - We can put the @Valid annotation on method parameters and fields to tell Spring that we want a method parameter or field to be validated.
    
    1. To validate the request body of an incoming HTTP request, we annotate the request body with the @Valid annotation in a REST controller:
        - We simply have added the @Valid annotation to the Input parameter, which is also annotated with @RequestBody to mark that it should be read from the request body. By doing this, we’re telling Spring to pass the object to a Validator before doing anything else.
        - When Spring Boot finds an argument annotated with @Valid, it automatically bootstraps the default JSR 380 implementation — Hibernate Validator — and validates the argument. When the target argument fails to pass the validation, Spring Boot throws a MethodArgumentNotValidException exception.

    ```
    class Input {
    
      @Min(1)
      @Max(10)
      private int numberBetweenOneAndTen;
    
      @Pattern(regexp = "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}$")
      private String ipAddress;
      
      // ...
    }
    
    -------------------------------------------------------------------------------
    
    @RestController
    class ValidateRequestBodyController {
    
      @PostMapping("/validateBody")
      ResponseEntity<String> validateBody(@Valid @RequestBody Input input) {
        return ResponseEntity.ok("valid");
      }
    
    }
    ```
  2. Validating Path Variables and Request Parameters: Validating path variables and request parameters works a little differently. We’re not validating complex Java objects in this case, since path variables and request parameters are primitive types like int or their counterpart objects like Integer or String. Instead of annotating a class field like above, we’re adding a constraint annotation (in this case @Min) directly to the method parameter in the Spring controller:
    - Note that we have to add Spring’s @Validated annotation to the controller at class level to tell Spring to evaluate the constraint annotations on method parameters.
    - The @Validated annotation is only evaluated on class level in this case, even though it’s allowed to be used on methods (we’ll learn why it’s allowed on method level when discussing validation groups later).
    - In contrast to request body validation a failed validation will trigger a ConstraintViolationException instead of a MethodArgumentNotValidException. Spring does not register a default exception handler for this exception, so it will by default cause a response with HTTP status 500 (Internal Server Error).
    ```
    @RestController
    @Validated
    class ValidateParametersController {
    
      @GetMapping("/validatePathVariable/{id}")
      ResponseEntity<String> validatePathVariable(
          @PathVariable("id") @Min(5) int id) {
        return ResponseEntity.ok("valid");
      }
      
      @GetMapping("/validateRequestParameter")
      ResponseEntity<String> validateRequestParameter(
          @RequestParam("param") @Min(5) int param) { 
        return ResponseEntity.ok("valid");
      }
    }
    ``` 
  









    
  
[^1]: Proxy is a design pattern. We create and use proxy objects when we want to add or modify some functionality of an already existing class. The proxy object is used instead of the original one. Usually, the proxy objects have the same methods as the original one and in Java proxy classes usually extend the original class. The proxy has a handle to the original object and can call the method on that.
[^2]: https://www.baeldung.com/exception-handling-for-rest-with-spring