1. List all of the annotations you learned from class and homework to
   annotaitons.md
2. What is Spring and Springboot? What is the benfits of using Srpingboot?
   * The Spring Framework provides a comprehensive programming and configuration model for modern Java-based enterprise applications - on any kind of deployment platform.
   * Spring Boot is a tool that makes developing web application and microservices with Spring Framework faster and easier through three core capabilities:Autoconfiguration, An opinionated approach to configuration, The ability to create standalone applications
   * These features work together to provide you with a tool that allows you to set up a Spring-based application with minimal configuration and setup.
3. What is IOC and What is DI?
   * Spring IoC Container is the core of Spring Framework. It creates the objects, configures and assembles their dependencies, manages their entire life cycle. The Container uses Dependency Injection(DI) to manage the components that make up the application. It gets the information about the objects from a configuration file(XML) or Java Code or Java Annotations and Java POJO class. These objects are called Beans. Since the Controlling of Java objects and their lifecycle is not done by the developers, hence the name Inversion Of Control.
   * Dependency Injection(DI) is the main functionality provided by Spring IOC(Inversion of Control). The Spring-Core module is responsible for injecting dependencies through either Constructor or Setter methods. The design principle of Inversion of Control emphasizes keeping the Java classes independent of each other and the container frees them from object creation and maintenance. These classes, managed by Spring, must adhere to the standard definition of Java-Bean. DI in Spring also ensures loose-coupling between the classes.
4. What is @CompnonentScan?
   * One of the most important annotations in spring is @ComponentScan which is used along with the @Configuration annotation to specify the packages that we want to be scanned. @ComponentScan without arguments tells Spring to scan the current package and all of its sub-packages.
5. How to define which package spring need to scan in xml and annotaiton?
   * xml: <context:component-scan base-package="com.xx.xxxx"/>
   * annotation: @ComponentScan(basePackages = {"com.xx.xxxx"})
6. What is @SpringbootApplication?
   * Spring Boot @SpringBootApplication annotation is used to mark a configuration class that declares one or more @Bean methods and also triggers auto-configuration and component scanning. Itâ€™s same as declaring a class with @Configuration, @EnableAutoConfiguration and @ComponentScan annotations.
7. How many ways wo can define a bean?
   1.  @Service, @Repository, @Component, @Controller
   2. @Bean on method
   3. xml file definition
8. What is default bean name for @Component and @Bean?
   * Default bean name is method name converting the first character to lower case.
9. What is the difference between @component and @service,@repository?
   * The major difference between these stereotypes is that they are used for different classifications. When we annotate a class for auto-detection, we should use the respective stereotype.
10. How many annotaitons we can use to inject the bean?
    * @Autowire, @Resource, @Inject
11. Tell me the three types to do dependency injection(How can we inject the beans
    in Spring)? Which way is better and why?
    * Constructor based dependency injection
    * Setter based dependency injection
    * Field based dependency injection
    * Constructor is better. Constructor injection makes code more robust. It allows us to create immutable objects, preventing NullPointerExceptions and other errors.
12. If we have multiple beans for one type, how to set one is primary? and how to let
    the spring to pick one bean to inject if no primay.
    * Use @Primary to set primary. Use @Qualifier to assign specific impl class.
13. What is the difference between BeanFactory and ApplicationContext in Spring?
    * BeanFactory loads beans on-demand, while ApplicationContext loads all beans at startup. Thus, BeanFactory is lightweight as compared to ApplicationContext.
    * ApplicationContext enhances BeanFactory in a more framework-oriented style and provides several features that are suitable for enterprise applications.For instance, it provides messaging (i18n or internationalization) functionality, event publication functionality, annotation-based dependency injection, and easy integration with Spring AOP features.
    * The ApplicationContext automatically registers BeanFactoryPostProcessor and BeanPostProcessor at startup. On the other hand, the BeanFactory does not register these interfaces automatically.
    * The ApplicationContext comes with advanced features, including several that are geared towards enterprise applications, while the BeanFactory comes with only basic features. Therefore, it's generally recommended to use the ApplicationContext, and we should use BeanFactory only when memory consumption is critical.
14. What is the Scope of a Bean? and list the examples for each scope.
    * Scopes a single bean definition to any number of object instances. Scopes a single bean definition to the lifecycle of a single HTTP request; that is each and every HTTP request will have its own instance of a bean created off the back of a single bean definition.
15. Configure a bean using xml. If bean has parameters/dependencies, how can we
    configure the bean? (you can google the tutorial how to configure beans in xml,
    and feel free to ask me any quesitons if you don't understand. it is a little bit old,
    I am not sure if I need to exaplain it in class)
    * Configure a bean using xml
    ```java
    public class AppConfig {
    
        public TransferService transferService() {
            return new TransferServiceImpl();
        }
    }
    ```
    ```xml
    <beans>
    <bean name="transferService" class="com.acme.TransferServiceImpl"/>
    </beans>
    ```
    * If bean has parameters/dependencies
    ```java
    public class ExampleBean {

    private AnotherBean beanOne;
    private YetAnotherBean beanTwo;
    private int i;

    public void setBeanOne(AnotherBean beanOne) {
        this.beanOne = beanOne;
    }

    public void setBeanTwo(YetAnotherBean beanTwo) {
        this.beanTwo = beanTwo;
    }

    public void setIntegerProperty(int i) {
        this.i = i;
    }    
    }
    ```
    ```xml
    <bean id="exampleBean" class="examples.ExampleBean">
    
      <!-- setter injection using the nested <ref/> element -->
    <property name="beanOne"><ref bean="anotherExampleBean"/></property>
    
      <!-- setter injection using the neater 'ref' attribute -->
      <property name="beanTwo" ref="yetAnotherBean"/>
      <property name="integerProperty" value="1"/>
    </bean>
    
    <bean id="anotherExampleBean" class="examples.AnotherBean"/>
    <bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
    ```
