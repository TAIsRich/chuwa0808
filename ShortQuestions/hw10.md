### 3. What is JPQL?
- JPQL stands for Java Persistence Query Language in JPA specification that is used to create queries against entities to store in a relational database.
- JPQL can retrieve information or data using SELECT clause, can do bulk updates using UPDATE clause and DELETE clause. EntityManager.createQuery() API will support for querying language.
- JPQL syntax is very similar to the syntax of SQL, a JPQL query can retrieve an entity object rather than field result set from database, as with SQL. The JPQL query structure as follows.
```
SELECT ... FROM ...
[WHERE ...]
[GROUP BY ... [HAVING ...]]
[ORDER BY ...]

DELETE FROM ... [WHERE ...]
 
UPDATE ... SET ... [WHERE ...]
```

### 4. What is @NamedQuery and @NamedQueries?
- Basically @NameQueries annotation is used to define the multiple named queries, adn the @NameQuery annotation is used to define the single named query
```
@NamedQueries(  
    {  
        @NamedQuery(  
        name = "findEmployeeByName",  
        query = "from Employee e where e.name = :name"  
        )  
    }  
)  
```

- The following @NamedQuery annotation defines a query whose name is "Country.findAll" that retrieves all the Country objects in the database:
```
@NamedQuery(name="Country.findAll", query="SELECT c FROM Country c") 
```
- The @NamedQuery annotation contains four elements - two of which are required and two are optional. The two required elements, name and query define the name of the query and the query string itself and are demonstrated above. The two optional elements, lockMode and hints, provide static replacement for the setLockMode and setHint methods.
- Every @NamedQuery annotation is attached to exactly one entity class or mapped superclass - usually to the most relevant entity class. But since the scope of named queries is the entire persistence unit, names should be selected carefully to avoid collision (e.g. by using the unique entity name as a prefix).
- Attaching multiple named queries to the same entity class requires wrapping them in a @NamedQueries annotation, as follows:
```
@Entity

@NamedQueries({
    @NamedQuery(name="Country.findAll",
                query="SELECT c FROM Country c"),
    @NamedQuery(name="Country.findByName",
                query="SELECT c FROM Country c WHERE c.name = :name"),
}) 
public class Country {
  ...
}
```
### 5. What is @Query? In which Interface we write the sql or JPQL?
- The @Query annotation takes precedence over named queries, which are annotated with @NamedQuery or defined in an orm.xml file.
- It's a good approach to place a query definition just above the method inside the repository rather than inside our domain model as named queries. The repository is responsible for persistence, so it's a better place to store these definitions.
- By default, the query definition uses JPQL.
  - Let's look at a simple repository method that returns active User entities from the database:
  ```
  @Query("SELECT u FROM User u WHERE u.status = 1")
  Collection<User> findAllActiveUsers();
  ```
- We can use also native SQL to define our query. All we have to do is set the value of the nativeQuery attribute to true and define the native SQL query in the value attribute of the annotation:
  ```
  @Query(
  value = "SELECT * FROM USERS u WHERE u.status = 1", nativeQuery = true)
  Collection<User> findAllActiveUsersNative();
  ```
### 6. What is HQL and Criteria Queries?
- Hibernate Query Language (HQL) is an object-oriented query language, similar to SQL, but instead of operating on tables and columns, HQL works with persistent objects and their properties. HQL queries are translated by Hibernate into conventional SQL queries, which in turns perform action on database.
```
String hql = "SELECT E.firstName FROM Employee E";
Query query = session.createQuery(hql);
List results = query.list();
```

- Hibernate provides alternate ways of manipulating objects and in turn data available in RDBMS tables. One of the methods is Criteria API, which allows you to build up a criteria query object programmatically where you can apply filtration rules and logical conditions.
- The Hibernate Session interface provides createCriteria() method, which can be used to create a Criteria
- Following is the simplest example of a criteria query is one, which will simply return every object that corresponds to the Employee class.
```
Criteria cr = session.createCriteria(Employee.class);
List results = cr.list();
```

### 7. What is EnityManager?
- EntityManager is part of the Java Persistence API. Chiefly, it implements the programming interfaces and lifecycle rules defined by the JPA 2.0 specification.
- JPA EntityManager is used to access a database in a particular application. It is used to manage persistent entity instances, to find entities by their primary key identity, and to query over all entities.
### 8. What is SessionFactory and Session?
- SessionFactory is an interface available in org.hibernate package which extends Referenceable and Serializable interface and provides factory methods to get session object.
- SessionFactory is thread safe so multiple threads can access the SessionFactory at the same time.
- SessionFactory is Immutable. Once we create SessionFactory we can not modify it(If you look SessionFactory methods we don’t have any setter kind of method)
- SessionFactory is created at the time of application startup, it reads all information from the configuration file(hibernate.cfg.xml file).
```
SessionFactory sessionFactory = new Configuration().configure().buildSessionFactory();
```

- The session is not thread-safe.
- The main use of the Session object to perform create, get, and delete operations for java classes(entity).
- The first level cache belongs to the session object. 
### 9. What is Transaction? how to manage your transaction?
- Transactions manage the changes that you perform in one or more systems. These can be databases, message brokers, or any other kind of software system. The main goal of a transaction is to provide ACID(atomicity, consistency, isolation, and durability) characteristics to ensure the consistency and validity of your data
- If this method run successfully, it save the related data to both the order table and
payment table
- If this method throw any exception or run failed. it save nothing to both tables.
- If it saved data in one table, however failed in second table, it rollback;

- Spring provides all the boilerplate code that’s required to start, commit, or rollback a transaction. It also integrates with Hibernate’s and JPA’s transaction handling. If you’re using Spring Boot, this reduces your effort to a @Transactional annotation on each interface, method, or class that shall be executed within a transactional context.
- The @Transactional annotation tells Spring that a transaction is required to execute this method. When you inject the AuthorService somewhere, Spring generates a proxy object that wraps the AuthorService object and provides the required code to manage the transaction.
```

@Service
public class AuthorService {     
    private AuthorRepository authorRepository;     
     
    public AuthorService(AuthorRepository authorRepository) {               
        this.authorRepository = authorRepository;     
    }     
     
    @Transactional    
    public void updateAuthorNameTransaction() {         
        Author author = authorRepository.findById(1L).get(); 
        author.setName("new name");     
    } 
}
```
### 10. Write a simple factory design pattern
```
public interface phone{
	void produce();
}


public class iphone implements phone{
	@Override
	public void produce(){
		....
	}
}

public class xiaomi implements phone{
	@Override
	public void produce(){
		....
	}
}


public class phoneFactory{
	public phone createPhone(String typeOfPhone){
		if(typeOfPhone == null){
			return null;
		}
	
	
		switch(typeOfPhone){
			case "iphone":
				return new iphone();
				break;
			case "xiaomi":
				return new xiaomi();
				break;
				
			default:
				return null;
		}
	

  	}
	
}


public class Client{
	public static void main(String[] args){
		phoneFactory fac = new phoneFactory();
		
		phone myPhone = fac.createPhone("iphone");
		
		myPhone.produce();
	}
}

```