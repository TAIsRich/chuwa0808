## HW16

### 1. List all of the new learned annotations to your annotations.md

### 2. what is selenium(YouTube)?
```
Selenium is one of the most widely used open source Web UI (User Interface) automation testing suite.
It is user-behavior simulation
```

### 3. what is cucumber(youtueb)?
```
Cucumber is a software tool used by the testers to develop test cases for the testing of behavior of the software. It has Given, when and then.
```
### 4. what is JMeter(youtube)?
```
JMeter is a software that can perform load test, performance-oriented business (functional) test, regression test, etc., on different protocols or technologies.
```
### 5. what is unit-test?
```
A unit test is a way of testing a unit - the smallest piece of code that can be logically isolated in a system. In most programming languages, that is a function, a subroutine, a method or property. 
```
### 6. What is the life circle of Junit?
```
The complete lifecycle of a test case can be seen in three phases with the help of annotations.
1.	Setup: This phase puts the the test infrastructure in place. JUnit provides class level setup (@BeforeAll) and method level setup (@BeforeEach). Generally, heavy objects like databse comnections are created in class level setup while lightweight objects like test objects are reset in the method level setup.
2.	Test Execution: In this phase, the test execution and assertion happen. The execution result will signify a success or failure.
3.	Cleanup: This phase is used to cleanup the test infrastructure setup in the first phase. Just like setup, teardown also happen at class level (@AfterAll) and method level (@AfterEach).

```
### 7. Is @BeforeAll method should be Class level(static)?
```
Yes, @BeforeAll  annotation method is static method, as it is class level.
```
### 8. What is Mockito? and what is its limitations?
```
Mockito is a JAVA-based library used for unit testing applications. This open-source library plays an important role in automated unit tests for the purpose of test-driven development or behavior-driven development. It uses a mock interface to add dummy functionality in the unit testing. It also uses Java reflection to create mock objects for an interface to test it.

Some limitations of the mockito are,
•	It cannot mock constructors or static methods.
•	It requires Java version 6 plus to run.
•	It also cannot mock equals(), hashCode() methods.
•	VM mocking is only possible on VMs that are supported by Objenesis.
```
### 9. What is @Mock and what is @InjectMocks?
```
@Mock creates a mock, and @InjectMocks creates an instance of the class and injects the mocks that are created with the @Mock annotations into this instance.
```
### 10. What is the stubbing?
```
Stubs are the objects that hold predefined data and uses it to give responses during tests. In other words, a stub is an object that resembles a real object with the minimum number of methods needed for a test. Stubs are used when we don't want to use objects that would give a response with real data. A stub is referred to as the lightest, and the most static version of the test doubles.
The main functions of the stubs are:
o	It always returns the predefined output regardless of the input.
o	It can be used to resemble the database objects.
o	Stubs are used to reduce the complexities that occur during the creation of the real objects. They are mainly used for performing state verification.
```
### 11. what is Mockito ArgumentMatchers
```
Argument matchers are mainly used for performing flexible verification and stubbing in Mockito. It extends ArgumentMatchers class to access all the matcher functions. Mockito uses equal() as a legacy method for verification and matching of argument values. In some cases, we need more flexibility during the verification of argument values, so we should use argument matchers instead of equal() method. The ArgumentMatchers class is available in org.mockito package.
```
### 12. what is Hamcrest Matchers
```
Hamcrest is the well-known framework used for unit testing in the Java ecosystem. It's bundled in JUnit and simply put, it uses existing predicates – called matcher classes – for making assertions.
```
### 13. do you know @spy? what is difference between @spy and @Mock?
```
Spies are known as partially mock objects. It means spy creates a partial object or a half dummy of the real object by stubbing or spying the real ones. In spying, the real object remains unchanged, and we just spy some specific methods of it. In other words, we take the existing (real) object and replace or spy only some of its methods.


@spy and @Mock can be used to mock methods or fields. The difference is that in mock, you are creating a complete mock or fake object while in spy, there is the real object and you just spying or stubbing specific methods of it.

```
### 14. briefly reading this articles
a. https://www.javatpoint.com/examples-of-mockito-and-junit-in-eclipse
-ide
b. https://www.javatpoint.com/junit-tutorial
c. https://www.javatpoint.com/testng-tutorial
d. https://www.javatpoint.com/jmeter-tutorial

