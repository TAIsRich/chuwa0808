
### 3.  What is JPQL?
JPQL is Java Persistence Query Language defined in JPA specification. It is used to create queries against entities to store in a relational database. JPQL is developed based on SQL syntax

### 4. What is @NamedQuery and @NamedQueries?
   @NameQueries annotation is used to define the multiple named queries.
   @NameQuery annotation is used to define the single named query.

### 5. What is @Query? In which Interface we write the sql or JPQL?
The @Query annotation takes precedence over named queries, which are annotated with @NamedQuery or defined in an orm. xml file. It's a good approach to place a query definition just above the method inside the repository rather than inside our domain model as named queries
The @Query annotation declares finder queries directly on repository methods. While similar @NamedQuery is used on domain classes, Spring Data JPA @Query annotation is used on Repository interface. This frees the domain classes from persistence specific information, which is a good thing

### 6. What is HQL and Criteria Queries?
The Hibernate Criteria Query Language (HCQL) is used to fetch the records based on the specific criteria. The Criteria interface provides methods to apply criteria such as retreiving all the records of table whose salary is greater than 50000 etc

### 7. What is EnityManager?
The EntityManager API is used to create and remove persistent entity instances, to find entities by their primary key, and to query over entities. The set of entities that can be managed by a given EntityManager instance is defined by a persistence unit.

### 8. What is SessionFactory and Session?
   Most importantly, the SessionFactory in Hibernate is responsible for the creation of Session objects. The Hibernate Session provides methods such as save, delete and update, all of which are used to perform CRUD-based operations on the database to which the SessionFactory connects

### 10. What is Transaction? how to manage your transaction?
A transaction simply represents a unit of work. In such case, if one step fails, the whole transaction fails (which is termed as atomicity). A transaction can be described by ACID properties (Atomicity, Consistency, Isolation and Durability).
1. begin(): It starts a new transaction.
2. commit(): It ends the transaction and flush the associated session.
3. rollback(): It roll back the current transaction.
4. setTimeout(int seconds): It set the transaction timeout for any transaction started by a subsequent call to begin() on this instance.

### 5. Write a simple factory design pattern.
public interface Laptop {
void runTests();
}

public class NormalLaptop implements Laptop {

    @Override
    public void runTests() {
       System.out.println("Running tests on a NormalLaptop...");
    }
}

public class GamingLaptop implements Laptop {

    @Override
    public void runTests() {
       System.out.println("Running tests on a GamingLaptop...");
    }
}

public class LaptopFactory {

    // Objects are created here 
    public Laptop createLaptop(String laptopType){
        if (laptopType == null) {
            return null;
        }

        switch (laptopType.toUpperCase()) {
            case "NormalLaptop":
                return new NormalLaptop();
                break;
            case "GamingLaptop":
                return new GamingLaptop();
                break;
                
            default:
                return null;
        }
    }
}

public class Client {
public static void main(String[] args) {
LaptopFactory laptopFactory = new LaptopFactory();

        // Get object of type GamingLaptop and run tests.
        Laptop myLaptop = laptopFactory.createLaptop("GamingLaptop");

        myLaptop.runTests();
    }
}