### 2. What is Spring and Springboot? What is the Benefits of using springboot?
- Despite the advantages of Spring Framework, authors decided to provide developers with some utilities that automate the configuration procedure and speed up the process of creating and deploying Spring applications. These utilities were combined under the general name of Spring Boot.
- While the Spring Framework focuses on providing flexibility, Spring Boot seeks to reduce code length and simplify web application development. By leveraging annotation and boilerplate configuration, Spring Boot reduces the time it takes to develop applications. This capability helps you create standalone applications with less or almost no configuration overhead.
- Ease of Dependency Management, To speed up the dependency management process, Spring Boot implicitly packages the required third-party dependencies for each type of Spring-based application and provides them through so-called starter packages (spring-boot-starter-web, spring-boot-starter-data-jpa, etc.). if you want to start using Spring Data JPA to access your database, just include the spring-boot-starter-data-jpa dependency in your project and you’ll be done (no need to look for compatible Hibernate database drivers and libraries).
- Automatic Сonfiguration: After choosing a suitable starter package, Spring Boot will try to automatically configure your Spring application based on the jar dependencies you added. For example, if you add Spring-boot-starter-web, Spring Boot will automatically configure registered beans such as DispatcherServlet, ResourceHandlers, and MessageSource. If you are using spring-boot-starter-jdbc, Spring Boot automatically registers the DataSource, EntityManagerFactory, and TransactionManager beans and reads the database connection information from the application.properties file.
- 
- **Benefits**: 
    - Fast and easy development of Spring-based applications;
    -  No need for the deployment of war files;
    -  The ability to create standalone applications;
    -  Helping to directly embed Tomcat, Jetty, or Undertow into an application;
    -  No need for XML configuration;
    -  Reduced amounts of source code;
    -  Additional out-of-the-box functionality;
    -  Easy start;
    -  Simple setup and management;
    -  Large community and many training programs to facilitate the familiarization period.
    
  

### 3. What is IOC and What is DI?
- Inversion of Control is a design principle used in object-oriented programming to reduce the coupling between computer code. The basic idea is to achieve decoupling between objects with dependencies by means of "third parties".
- The software system before the introduction of IOC containers, for instance, object A depends on object B, then object A in the initialization or run to a certain point, they must take the initiative to create object B or use the already created object B. Whether to create or use object B, the control is in their own hands.
- Software system after the introduction of the IOC container, this situation has completely changed, due to the addition of the IOC container, object A and object B lost direct contact between the object, so when object A runs to the need for object B, the IOC container will take the initiative to create an object B injected into the object A where needed. By comparing before and after, it is easy to see: object A gets dependent on the process of object B, from active behavior to passive behavior, the control is reversed, which is the origin of the name "inversion of control".

-----------------------
- Dependency injection means giving an object its instance variables
- What is dependency? If there is a class B instance inside class A, which means Class A has a dependency on Class B.
- As the example below, an object Father is used in the Human, which means the Human has a dependency on the Father class
```
public class Human {
    ...
    Father father;
    ...
    public Human() {
        father = new Father();
    }
}
```
- We need to use ***new Father(String name)*** to initialize if we want to change any father production.
- It is also hard to test the different influences of Father's object brought to Human, b/c the initialization of father writes inside the constructor of Human.
- The above initialization of the dependencies directly in the constructor is a Hard init approach, with the disadvantage that the two classes are not independent enough to test. We have another way of Init
```
public class Human {
    ...
    Father father;
    ...
    public Human(Father father) {
        this.father = father;
    }
}
```
- In the above code, we pass the father object as a parameter to the constructor. The Father object has been initialized externally before the Human constructor is called. This is what we call dependency injection, where the dependency is passed in externally instead of being initialized by ourselves. Now we see that the two problems in 1 above are well solved, and simply put, dependency injection has two main benefits.
    - Decoupling, decoupling dependencies from each other.
    - Because it is decoupled, it is easy to do unit testing, especially Mock testing.
- Some people will equate control reversal with dependency injection, but in fact they are fundamentally different.
  - Inversion of control is an idea
  - Dependency injection is a design pattern
- The IoC framework uses dependency injection as a way to implement Inversion of Control, but there are other ways to implement Inversion of Control

### 4. What is @CompnonentScan?
- Typically, in a Spring application, annotations like @Component, @Configuration, @Service, @Repository are specified on classes to mark them as Spring beans. The @ComponentScan annotation basically tells Spring Boot to scan the current package and its sub-packages in order to identify annotated classes and configure them as Spring beans. Thus, it designates the current package as the root package for component scanning.
- Spring can automatically scan a package for beans if component scanning is enabled.
- With Spring, we use the @ComponentScan annotation along with the @Configuration annotation to specify the packages that we want to be scanned. @ComponentScan without arguments tells Spring to scan the current package and all of its sub-packages. Let’s have look at following example, component classes available in reptiles base package and in crocodles, snakes sub-packages, they are annotated with @Component.
- @ComponentScan configures which packages to scan for classes with annotation configuration. We can specify the base package names directly with one of the basePackages or value arguments (value is an alias for basePackages)
```
@Configuration
@ComponentScan(basePackages = "com.baeldung.annotations")
class VehicleFactoryConfig {}


// we can also refer to classes
@Configuration
@ComponentScan(basePackageClasses = VehicleFactoryConfig.class)
class VehicleFactoryConfig {}
```
### 5. How to define which package spring need to scan in xml and annotaiton?
- Prior to annotations, we had to manually define all our beans and dependencies in XML configuration files. Now thanks to Spring's annotations, it can automatically discover and wire all our beans and dependencies for us. So, we can at least eliminate the XML needed for beans and dependencies. However, we should remember that annotations are useless unless we activate them. In order to activate them, we can add either <context:annotation-config> or <context:component-scan> on top of our XML file.
- The <context:annotation-config> annotation is mainly used to activate the dependency injection annotations. @Autowired, @Qualifier, @PostConstruct, @PreDestroy, and @Resource are some of the ones that <context:annotation-config> can resolve.
- Basically, <context:component-scan> detects the annotations by package scanning. To put it differently, it tells Spring which packages need to be scanned to look for the annotated beans or components. @Component, @Repository, @Service, @Controller, @RestController, and @Configuration are several ones that <context:component-scan> can detect.
- we need to define the package for scanning in both xml and annotation.
  - Toward the xml, it would be like: <context:component-scan base-package="com.chuwa.springbasic"/>
  - The annotation would be like: @ComponentScan(basePackages = {"com.chuwa.springbasic"})
  - we can also do @ComponentScan(basePackageClasses = ....class), but it's not suitable for this case.
### 6. What is @SpringbootApplication?
- The @SpringBootApplication annotation is a convenience annotation that combines the @EnableAutoConfiguration, @Configuration and the @ComponentScan annotations in a Spring Boot application. These annotations do the following:
  - @EnableAutoConfiguration – This enables Spring Boot’s autoconfiguration mechanism. Auto-configuration refers to creating beans automatically by scanning the classpath.

  - @ComponentScan – Typically, in a Spring application, annotations like @Component, @Configuration, @Service, @Repository are specified on classes to mark them as Spring beans. The @ComponentScan annotation basically tells Spring Boot to scan the current package and its sub-packages in order to identify annotated classes and configure them as Spring beans. Thus, it designates the current package as the root package for component scanning.

  - @Configuration – Designates the class as a configuration class for Java configuration. In addition to beans configured via component scanning, an application may desire to configure some additional beans via the @Bean annotation as demonstrated here. Thus, the return value of methods having the @Bean annotation in this class are registered as beans.
```
@SpringBootApplication
public class Main {
    public static void main(String[] args) {
          SpringApplication.run(Main.class, args);
      }
}
```
- The Main class has the @SpringBootApplication annotation
- It simply invokes the SpringApplication.run method. This starts the Spring application as a standalone application, runs the embedded servers and loads the beans.
- Normally, such a main class is placed in a root package above other packages. This enables component scanning to scan all the sub-packages for beans.
### 7. How many ways wo can define a bean?
- Creating Bean Inside an XML Configuration File (beans.xml)
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">

        <context:component-scan base-package="com.chuwa.springbasic"/>
        <bean id="dataNucleusChuwaNoComponent"  class="com.chuwa.springbasic.components.impl.DataNucleusChuwaNoComponent"></bean>
</beans>
```
- Using @Component Annotation like: @Controller, @Service, @Repository and @Component
- Using @Bean Annotation - @Bean is a method-level annotation and a direct analog of the XML <bean/> element. The annotation supports most of the attributes offered by <bean/> such as init-method, destroy-method, autowiring, lazy-init, dependency-check, depends-on and scope.
  - To declare a bean, simply annotate a method with the @Bean annotation. When JavaConfig encounters such a method, it will execute that method and register the return value as a bean within a BeanFactory. By default, the bean name will be that of the method name (see bean naming for details on how to customize this behavior).
```
@Configuration
public class AppConfig {
    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl();
    }
}
```
### 8. What is default bean name for @Component and @Bean?
- Default bean name for @Component: Spring uses the class name and converts the first letter to lowercase.
  - Example below, Spring creates a bean for the class LoggingService and registers it using the name “loggingService“
```
@Component
public class LoggingService {
}
```
- Default bean name for @Bean: 
### 9. What is the difference between @component and @service,@repository?
- @Component: it is a general purpose stereotype annotation which indicates that the class annotated with it, is a spring managed component.
- @Controller, @Service and @Repository are special types of @Component
```
@Target(value=TYPE)
@Retention(value=RUNTIME)
@Documented
@Component
public @interface Controller

@Target(value=TYPE)
@Retention(value=RUNTIME)
@Documented
@Component
public @interface Service

@Target(value=TYPE)
@Retention(value=RUNTIME)
@Documented
@Component
public @interface Repository
```
- @Service: the service layer classes that contain the business logic should be annotated with @Service. Apart from the fact that it is used to indicate that the class contains business logic, there is no special meaning to this annotation, however it is possible that Spring may add some additional feature to @Service in future, so it is always good idea to follow the convention.
- @Repository: the classes annotated with this annotation defines data repositories. It is used in DAO layer classes. @Repository has one special feature that it catches platform specific exceptions and re-throw them as one of the Spring’s unified unchecked exception i.e. DataAccessException
### 10. How many annotaitons we can use to inject the bean?
- @Resource:
```
//Match by Name
@Resource(name="namedFile")
private File defaultFile;

@Bean(name="namedFile")
    public File namedFile() {
        File namedFile = new File("namedFile.txt");
        return namedFile;
    }


//Match by Type 

@Resource
private File defaultFile;
//The test will still pass because if the @Resource annotation doesn't receive a bean name as 
//an attribute value, the Spring Framework will proceed with the next level of precedence, 
//match-by-type, in order to try resolve the dependency.


//Match by Qualifier
@Resource
@Qualifier("defaultFile")
private File dependency1;

```
  - @Inject
```
//Match by Type
@Inject
private ArbitraryDependency fieldInjectDependency;

@Bean
public ArbitraryDependency injectDependency() {
    ArbitraryDependency injectDependency = new ArbitraryDependency();
    return injectDependency;
}



//Match by Qualifier
@Inject
@Qualifier("defaultFile")
private ArbitraryDependency defaultDependency;


//Match by Name
 @Inject
    @Named("yetAnotherFieldInjectDependency")
    private ArbitraryDependency yetAnotherFieldInjectDependency;
    

 @Bean
    public ArbitraryDependency yetAnotherFieldInjectDependency() {
        ArbitraryDependency yetAnotherFieldInjectDependency =
          new YetAnotherArbitraryDependency();
        return yetAnotherFieldInjectDependency;
    }
```
  - @Autowired
```
//Match by Type
@Autowired
private ArbitraryDependency fieldDependency;

 @Bean
    public ArbitraryDependency autowiredFieldDependency() {
        ArbitraryDependency autowiredFieldDependency =
          new ArbitraryDependency();
        return autowiredFieldDependency;
    }
    
    
//Match by Qualifier
@Autowired
@Qualifier("autowiredFieldDependency")
private FieldDependency fieldDependency1;



//Match by Name
 @Autowired
 private ArbitraryDependency autowiredFieldDependency;

```
### 11. Tell me the three types to do dependency injection(How can we inject the beans in Spring)? Which way is better and why?
- Constructor Based Dependency Injection: When the annotation @Autowired is used on top of the class constructor, it is referred to as Constructor-based Dependency Injection.
```
private Test test;

@Autowired
public whatever(Test test){
  this.test = test;
}
```
- Setter Based Dependency Injection: When the annotation @Autowired is used on top of the class’s setter method, it is referred to as Setter based Dependency Injection.
```
private Test test;

@Autowired
public void setWhatever(Test test){
  this.test = test;
}
```
- Field or Property-Based Dependency Injection: When the annotation @Autowired is used on top of the field or property in the class, it is referred to as Field-based Dependency Injection.
```
@Autowired
private Test test;
```
- the Constructor Dependency Injection is better, b/c  Good readability as it is separately present in the code, and Best in the case of loose coupling with the DI container as it is not even required to add @Autowired annotation in the code.
### 12. If we have multiple beans for one type, how to set one is primary? and how to let the spring to pick one bean to inject if no primay.
- we can set @primary on the top of one of the bean
```
@Configuration
public class Config {

    @Bean
    public Employee JohnEmployee() {
        return new Employee("John");
    }

    @Bean
    @Primary
    public Employee TonyEmployee() {
        return new Employee("Tony");
    }
}
```
- If we want to let the spring to pick specify one, we can use @Qualifier, or change the name of property like below
```

@Autowired
@Qualifier("JohnEmployee")
private Employee fieldDependency1;


@Autowired
private Employee JohnEmployee;
```
### 13. What is the difference between BeanFactory and ApplicationContext in Spring?
- This is the root interface for accessing a Spring bean container. It is the actual container that instantiates, configures, and manages a number of beans. These beans collaborate with one another and thus have dependencies between themselves. These dependencies are reflected in the configuration data used by the BeanFactory. This interface is implemented by the objects that hold a number of bean definitions, each uniquely identified by a String name. The most common implementation class used for this BeanFactory is XmlBeanFactory available in org.springframework.beans.factory.xml package.
- BeanFactory is deprecated from Spring 3.0.
```
ClassPathResource resource = new ClassPathResource("beans.xml");
XmlBeanFactory factory = new XmlBeanFactory(resource);
```
- This interface is designed on top of the BeanFactory interface. The ApplicationContext interface is the advanced container that enhances BeanFactory functionality in a more framework-oriented style. While the BeanFactory provides basic functionality for managing and manipulating beans, often in a programmatic way, the ApplicationContext provides extra functionality like MessageSource, Access to resources, Event propagation to beans, Loading of multiple (hierarchical) contexts etc. There are so many implementation classes that can be used such as ClassPathXmlApplicationContext, FileSystemXmlApplicationContext, AnnotationConfigWebApplicationContext etc.
```
ApplicationContext context = new ClassPathXmlApplicationContext("bean.xml");
context.getBean("dependencyInjectionByTypeByName", DependencyInjectionByTypeByName.class).printFirstMessage();

ApplicationContext context = new AnnotationConfigApplicationContext(BeanConfig.class);
context.getBean("dependencyInjectionByTypeByName", DependencyInjectionByTypeByName.class).printFirstMessage();
```
### 14. What is the Scope of a Bean? and list the examples for each scope.
- The singleton scope(default): If a scope is set to singleton, the Spring IoC container creates exactly one instance of the object defined by that bean definition. This single instance is stored in a cache of such singleton beans, and all subsequent requests and references for that named bean return the cached object.
```
Let's create a Person entity to exemplify the concept of scopes:
public class Person {
    private String name;

    // standard constructor, getters and setters
}


Afterwards, we define the bean with the singleton scope by using the @Scope annotation:
@Bean
@Scope("singleton")
public Person personSingleton() {
    return new Person();
}

//Now we can proceed to write a test that shows that two objects referring to the same bean will have the same values, 
//even if only one of them changes their state, as they are both referencing the same bean instance:

private static final String NAME = "John Smith";

@Test
public void givenSingletonScope_whenSetName_thenEqualNames() {
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext("scopes.xml");

    Person personSingletonA = (Person) applicationContext.getBean("personSingleton");
    Person personSingletonB = (Person) applicationContext.getBean("personSingleton");

    personSingletonA.setName(NAME);
    Assert.assertEquals(NAME, personSingletonB.getName());

    ((AbstractApplicationContext) applicationContext).close();
}
```
- The prototype scope: If the scope is set to prototype, the Spring IoC container creates a new bean instance of the object every time a request for that specific bean is made. As a rule, use the prototype scope for all state-full beans and the singleton scope for stateless beans.
```
@Bean
@Scope("prototype")
public Person personPrototype() {
    return new Person();
}

//We will now write a similar test as before that shows two objects requesting the same bean name with the prototype 
//scope. They will have different states as they are no longer referring to the same bean instance:


private static final String NAME = "John Smith";
private static final String NAME_OTHER = "Anna Jones";

@Test
public void givenPrototypeScope_whenSetNames_thenDifferentNames() {
    ApplicationContext applicationContext = 
      new ClassPathXmlApplicationContext("scopes.xml");

    Person personPrototypeA = (Person) applicationContext.getBean("personPrototype");
    Person personPrototypeB = (Person) applicationContext.getBean("personPrototype");

    personPrototypeA.setName(NAME);
    personPrototypeB.setName(NAME_OTHER);

    Assert.assertEquals(NAME, personPrototypeA.getName());
    Assert.assertEquals(NAME_OTHER, personPrototypeB.getName());

    ((AbstractApplicationContext) applicationContext).close();
}

```
- Web Aware Scopes: The request scope creates a bean instance for a single HTTP request, while the session scope creates a bean instance for an HTTP Session.
```
@Bean
@Scope(value = WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.TARGET_CLASS)
public HelloMessageGenerator requestScopedBean() {
    return new HelloMessageGenerator();
}
```
- Session Scope: This scopes a bean definition to an HTTP session. Only valid in the context of a web-aware Spring ApplicationContext.
```
@Bean
@Scope(value = WebApplicationContext.SCOPE_SESSION, proxyMode = ScopedProxyMode.TARGET_CLASS)
public HelloMessageGenerator sessionScopedBean() {
    return new HelloMessageGenerator();
}
```
### 15. Configure a bean using xml. If bean has parameters/dependencies, how can we configure the bean? (you can google the tutorial how to configure beans in xml, and feel free to ask me any quesitons if you don't understand. it is a little bit old, I am not sure if I need to exaplain it in class)
- Configure a bean using xml
```
public class AppConfig {
    
    public TransferService transferService() {
        return new TransferServiceImpl();
    }
}


<beans>
    <bean name="transferService" class="com.acme.TransferServiceImpl"/>
</beans>
```
- If bean has parameters/dependencies
```
public class ExampleBean {

    private AnotherBean beanOne;
    private YetAnotherBean beanTwo;
    private int i;

    public void setBeanOne(AnotherBean beanOne) {
        this.beanOne = beanOne;
    }

    public void setBeanTwo(YetAnotherBean beanTwo) {
        this.beanTwo = beanTwo;
    }

    public void setIntegerProperty(int i) {
        this.i = i;
    }    
}

<bean id="exampleBean" class="examples.ExampleBean">

  <!-- setter injection using the nested <ref/> element -->
  <property name="beanOne"><ref bean="anotherExampleBean"/></property>

  <!-- setter injection using the neater 'ref' attribute -->
  <property name="beanTwo" ref="yetAnotherBean"/>
  <property name="integerProperty" value="1"/>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>


```