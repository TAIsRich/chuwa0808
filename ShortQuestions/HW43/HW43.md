### 1. List all of the annotations you learned from class and homework to annotaitons.md

### 2. What is Spring and Springboot? What is the benfits of using Srpingboot?
This Spring framework uses various new techniques such as Aspect-Oriented Programming (AOP), Plain Old Java Object (POJO), and dependency injection (DI), to develop enterprise applications.

The Spring framework can be considered as a collection of sub-frameworks, also called layers, such as Spring AOP. Spring Object-Relational Mapping (Spring ORM). Spring Web Flow, and Spring Web MVC. You can use any of these modules separately while constructing a Web application. The modules may also be grouped together to provide better functionalities in a Web application.

Spring Boot is built on top of the conventional spring framework. So, it provides all the features of spring and is yet easier to use than spring. Spring Boot is a microservice-based framework and making a production-ready application in very less time. In Spring Boot everything is auto-configured. We just need to use proper configuration for utilizing a particular functionality. Spring Boot is very useful if we want to develop REST API.

- Fast and easy development of Spring-based applications;
- No need for the deployment of war files;
- The ability to create standalone applications;
- Helping to directly embed Tomcat, Jetty, or Undertow into an application;
- No need for XML configuration;
- Reduced amounts of source code;

### 3. What is IOC and What is DI?
Dependency Injection(DI):
Dependency injection generally means passing a dependent object as a parameter to a method, rather than having the method create the dependent object.
What it means in practice is that the method does not have a direct dependency on a particular implementation; any implementation that meets the requirements can be passed as a parameter.

With this implementation of objects defines their dependencies. And spring makes it available.
This leads to loosely coupled application development.

Quick Example:EMPLOYEE OBJECT WHEN CREATED,IT WILL AUTOMATICALLY CREATE ADDRESS OBJECT (if address is defines as dependency by Employee object)*.

Inversion of Control(IoC) Container:
This is common characteristic of frameworks, IoC manages java objects
- from instantiation to destruction through its BeanFactory.
- Java components that are instantiated by the IoC container are called beans, and the IoC container manages a bean's scope, lifecycle events, and any AOP features for which it has been configured and coded.

By implementing Inversion of Control, a software/object consumer get more controls/options over the software/objects, instead of being controlled or having less options.

Inversion of control as a design guideline serves the following purposes:
- There is a decoupling of the execution of a certain task from implementation.
- Every module can focus on what it is designed for.
- Modules make no assumptions about what other systems do but rely on their contracts.
- Replacing modules has no side effect on other modules

### 4. What is @CompnonentScan?
One of the most important annotations in spring is @ComponentScan which is used along with the @Configuration annotation to specify the packages that we want to be scanned. @ComponentScan without arguments tells Spring to scan the current package and all of its sub-packages.
### 5. How to define which package spring need to scan in xml and annotaiton?
Component scan an also be done with XML configuration:
For this, use the <context:component-scan> tag, and specify the packages that are the locations.

```java
@Configuration
	@ComponentScan(basePackages = {
			"com.in28minutes.spring.example1.businessservice",
			"com.in28minutes.spring.example1.dataservice.stub"})

	class SpringContext {
	}

@ComponentScan("com.in28minutes.springboot")
	
	@SpringBootApplication
	public class SpringBootApllicationIn10Steps {
		//...
	}
```
### 6. What is @SpringbootApplication?
Spring Boot SpringApplication class is used to bootstrap and launch a Spring application from a Java main method. This class automatically creates the ApplicationContext from the classpath, scan the configuration classes and launch the application.
### 7. How many ways wo can define a bean?
Method 1: Creating Bean Inside an XML Configuration File (beans.xml)
One of the most popular ways to create a spring bean is to define a bean in an XML configuration file something like this.
```java
<bean id="AnyUniqueId" class="YourClassName">
</bean>
```

Method 2: Using @Component Annotation 
Spring Annotations are a form of metadata that provides data about a program. Annotations are used to provide supplemental information about a program. It does not have a direct effect on the operation of the code they annotate. It does not change the action of the compiled program. @Component is an annotation that allows Spring to automatically detect the custom beans. 

Example: Suppose we have already a Java project and all the Spring JAR files are imported into that project. Now let’s create a simple class named College and inside the class, we have a simple method. Below is the code for the College.java file.

```java
// Java Program to Illustrate College Class
 
package ComponentAnnotation;
 
// Importing required classes
import org.springframework.stereotype.Component;
 
@Component("collegeBean")
 
// Class
public class College {
 
    // Method
    public void test()
    {
        // Print statement
        System.out.println("Test College Method");
    }
}
```

Method 3: Using @Bean Annotation
One of the most important annotations in spring is the @Bean annotation which is applied on a method to specify that it returns a bean to be managed by Spring context. Spring Bean annotation is usually declared in Configuration classes methods.

```java

// Java Program to Illustrate Configuration in College Class
 
package BeanAnnotation;
 
// Importing required classes
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
 
@Configuration
public class CollegeConfig {
 
    // Using Bean annotation to create
    // College class Bean
    @Bean
 
    // Here the method name is the
    // bean id/bean name
    public College collegeBean()
    {
 
        // Return the College object
        return new College();
    }
}
```
### 8. What is default bean name for @Component and @Bean?
If the annotation's value doesn't indicate a bean name, an appropriate name will be built based on the short name of the class (with the first letter lower-cased), unless the two first letters are uppercase. For example:

com.xyz.FooServiceImpl -> fooServiceImpl
com.xyz.URLFooServiceImpl -> URLFooServiceImpl

### 9. What is the difference between @component and @service, @repository?
@Component is a generic stereotype for any Spring-managed component.
@Service annotates classes at the service layer.
@Repository annotates classes at the persistence layer, which will act as a database repository.

The major difference between these stereotypes is that they are used for different classifications. 

We can use @Component across the application to mark the beans as Spring's managed components. Spring will only pick up and register beans with @Component, and doesn't look for @Service and @Repository in general.

@Repository’s job is to catch persistence-specific exceptions and re-throw them as one of Spring’s unified unchecked exceptions.

For this, Spring provides PersistenceExceptionTranslationPostProcessor, which we are required to add in our application context (already included if we're using Spring Boot):

<bean class=
  "org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor"/>
This bean post processor adds an advisor to any bean that’s annotated with @Repository.

We mark beans with @Service to indicate that they're holding the business logic. Besides being used in the service layer, there isn't any other special use for this annotation.

### 10. How many annotations we can use to inject the bean?
When I looked under the hood I determined that the ‘@Autowired’ and ‘@Inject’ annotation behave identically. Both of these annotations use the ‘AutowiredAnnotationBeanPostProcessor’ to inject dependencies. ‘@Autowired’ and ‘@Inject’ can be used interchangeable to inject Spring beans. However the ‘@Resource’ annotation uses the ‘CommonAnnotationBeanPostProcessor’ to inject dependencies. Even though they use different post processor classes they all behave nearly identically. Below is a summary of their execution paths.

@Autowired and @Inject

- Matches by Type
- Restricts by Qualifiers
- Matches by Name

@Resource

- Matches by Name
- Matches by Type
- Restricts by Qualifiers (ignored if match is found by name)

Spring Annotation Style Best Practices

- Explicitly name your component [@Component("beanName")]
- Use '@Resource' with the 'name' attribute [@Resource(name="beanName")]
- Avoid '@Qualifier' annotations unless you want to create a list of similar beans. For example you may want to mark a set of rules with a specific '@Qualifier' annotation. This approach makes it simple to inject a group of rule classes into a list that can be used for processing data.
- Scan specific packages for components [context:component-scan base-package="com.sourceallies.person"]. While this will result in more component-scan configurations it reduces the chance that you'll add unnecessary components to your Spring context.

### 11. Tell me the three types to do dependency injection(How can we inject the beans in Spring)? Which way is better and why?
1. Constructor-Based Injection:
In a constructor-based injection, Spring will use the matching constructor to resolve and inject the dependency.

We can either configure the beans in applicationContext.xml:
```java
<bean id="address" class="com.programmergirl.domain.Address"/>
<bean id="person" class="com.programmergirl.domain.Person">
    <constructor-arg ref="address"/>
</bean>
```
Or, we can enable the <component-scan/> in our applicationContext.xml:
```java
<context:component-scan base-package="com.programmergirl.domain" />
```

On enabling component scan, we can make the Spring configurations using the annotations. Our classes would then look like:
```java
package com.programmergirl.domain;
@Component
public class Person {
    private Address address;
    @Autowired
    public Person(Address address) {
        this.address = address;
    }
}
package com.programmergirl.domain;
@Component
public class Address {
   ...
}
```

Spring, by default, wires the beans by their type. If there are more than one beans of the same type, we can use @Qualifier annotation to reference a bean by its name:
```java
@Component
public class Person {
    private Address address;
    @Autowired
    @Qualifier("address1")
    public void setAddress(Address address) {
        this.address = address;
    }
}
```

Assuming we have two Address beans – address1 and address2, our address1 bean will be injected into Person class while dependency resolution.

2. Setter Injection:
Setter-based dependency injection is achieved through the setter method on the bean after instantiating it using a no-arg constructor or no-argument static factory.

We can configure it using XML as:
```java
<bean id="address" class="com.programmergirl.domain.Address"/>
<bean id="person" class="com.programmergirl.domain.Person">
    <property name="address" ref="address"/>
</bean>
```

On the other hand, when using annotations, we’ll have:
```java
@Component
public class Person {
    
    private Address address;
    ...
    @Autowired
    public void setAddress(Address address) {
        this.address = address;
    }
    
}
```

3. Property-Based Injection:
We can also inject dependencies using fields or properties of a class. To do so, we can simply use the @Autowired annotation over the field:
```java
@Component
public class Person {
    @Autowired
    private Address address;
    ...
}
```

considering we’re using annotation based configurations.
Noteworthy Points:
As per Spring documentation:

- We should use constructor injection for mandatory dependencies
- Setter-based injections should be used for dependencies that are optional in nature
- Spring uses reflection for injecting the field-injected dependencies. So, field-based injection is a costlier approach and we should avoid using it
### 12. If we have multiple beans for one type, how to set one is primary? and how to let the spring to pick one bean to inject if no primary.
we use @Primary to give higher preference to a bean when there are multiple beans of the same type.

The identifier of the parameter matches the name of one of the beans from the context (which is the same as the name of the method annotated with @Bean that returns its value). In this case, Spring chooses that bean for which the name is the same as the parameter.

The identifier of the parameter doesn’t match any of the bean names from the context and you have the following options:
- You marked one of the beans as primary. In this case, Spring selects the primary bean for injection.
- You can explicitly select a specific bean using the @Qualifier annotation.
- If none of the beans are primary and you don’t use @Qualifier either, the app fails with an exception, complaining of the fact that the context contains more beans of the same type, and Spring doesn’t know which one to choose.
### 13. What is the difference between BeanFactory and ApplicationContext in Spring?
The Spring Framework comes with two IOC containers – BeanFactory and ApplicationContext. The BeanFactory is the most basic version of IOC containers, and the ApplicationContext extends the features of BeanFactory.

BeanFactory loads beans on-demand(lazy loading), while ApplicationContext loads all beans at startup(eager loading). Thus, BeanFactory is lightweight as compared to ApplicationContext.

ApplicationContext enhances BeanFactory in a more framework-oriented style and provides several features that are suitable for enterprise applications.

For instance, it provides messaging (i18n or internationalization) functionality, event publication functionality, annotation-based dependency injection, and easy integration with Spring AOP features.

Apart from this, the ApplicationContext supports almost all types of bean scopes, but the BeanFactory only supports two scopes — Singleton and Prototype. Therefore, it's always preferable to use ApplicationContext when building complex enterprise applications.

The ApplicationContext automatically registers BeanFactoryPostProcessor and BeanPostProcessor at startup. On the other hand, the BeanFactory does not register these interfaces automatically.

The ApplicationContext comes with advanced features, including several that are geared towards enterprise applications, while the BeanFactory comes with only basic features. Therefore, it's generally recommended to use the ApplicationContext, and we should use BeanFactory only when memory consumption is critical.

### 14. What is the Scope of a Bean? and list the examples for each scope.
singleton : Scopes a single bean definition to a single object instance per Spring IoC container.

prototype : Scopes a single bean definition to any number of object instances.

request : Scopes a single bean definition to the lifecycle of a single HTTP request; that is each and every HTTP request will have its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring ApplicationContext.

session : Scopes a single bean definition to the lifecycle of a HTTP Session. Only valid in the context of a web-aware Spring ApplicationContext.

global session : Scopes a single bean definition to the lifecycle of a global HTTP Session. Typically only valid when used in a portlet context. Only valid in the context of a web-aware Spring ApplicationContext.

### 15. Configure a bean using xml. If bean has parameters/dependencies, how can we configure the bean? (you can google the tutorial how to configure beans in xml, and feel free to ask me any quesitons if you don't understand. it is a little bit old, I am not sure if I need to exaplain it in class)
```java
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context-3.0.xsd
    http://www.springframework.org/schema/aop
    http://www.springframework.org/schema/aop/spring-aop-3.0.xsd
    ">
 
    <bean id="country" class="org.arpit.java2blog.model.Country">
        <constructor-arg index="0" value="India"></constructor-arg>
        <constructor-arg index="1" value="20000"></constructor-arg>
    </bean>
    <context:annotation-config />
</beans>
```