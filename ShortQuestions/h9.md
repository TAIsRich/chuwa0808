
### 1.  List all of the annotations you learned from class and homework to annotaitons.md
@RestController
@Entity
@RequestMapping
@Autowired
@GetMapping
@PostMapping
@PutMapping
@DeleteMapping
@ResponseStatus
@SpringBootApplication

### 3. In postman, call of the APIs in PostController and CommentController



### 4.  what is JPA? and what is Hibernate?
The major difference between Hibernate and JPA is that Hibernate is a framework while JPA is API specifications. Hibernate is the implementation of all the JPA guidelines.

### 5.What is Hiraki? what is the benefits of connection pool?
1.HikariCP is a very fast lightweight Java connection pool. The API and overall codebase are relatively small (a good thing) and highly optimized. It also does not cut corners for performance like many other Java connection pool implementations. 
2.Constantly opening and closing connections can be expensive. Cache and reuse.
3.When activity spikes you can limit the number of connections to the database. This will force code to block until a connection is available. This is especially helpful in distributed environments.
4.Split out common operations into multiple pools. For instance, you can have a pool designated for OLAP connections and a pool for OLTP connections each with different configurations.

### 6.  What is the  @OneToMany, @ManyToOne, @ManyToMany? write some examples.
1.one-to-many mapping means that one row in a table is mapped to multiple rows in another table.
2.The ManyToOne annotation may be used within an embeddable class to specify a relationship from the embeddable class to an entity class. If the relationship is bidirectional, the non-owning OneToMany entity side must use the mappedBy element of the OneToMany annotation to specify the relationship field or property of the embeddable field or property on the owning side of the relationship
3.A relationship is a connection between two types of entities. In the case of a many-to-many relationship, both sides can relate to multiple instances of the other side.
Example 1:

     @ManyToOne(optional=false) 
     @JoinColumn(name="CUST_ID", nullable=false, updatable=false)
     public Customer getCustomer() { return customer; }


     Example 2:
 
     @Entity
        public class Employee {
        @Id int id;
        @Embedded JobInfo jobInfo;
        ...
     }

     @Embeddable
        public class JobInfo {
        String jobDescription; 
        @ManyToOne ProgramManager pm; // Bidirectional
     }

     @Entity
        public class ProgramManager {
        @Id int id;
        @OneToMany(mappedBy="jobInfo.pm")
        Collection<Employee> manages;
     }


### 7.What is the  cascade = CascadeType.ALL, orphanRemoval = true? and what are the other CascadeType and their features? In which situation we choose which one?
CascadeType.1.PERSIST : cascade type presist means that save() or persist() operations cascade to related entities.
CascadeType.2.MERGE : cascade type merge means that related entities are merged when the owning entity is merged.
CascadeType.3.REFRESH : cascade type refresh does the same thing for the refresh() operation.
CascadeType.4.REMOVE : cascade type remove removes all related entities association with this setting when the owning entity is deleted.
CascadeType.5.DETACH : cascade type detach detaches all related entities if a “manual detach” occurs.
CascadeType.6.ALL : cascade type all is shorthand for all of the above cascade operations.
 
### 8.What is the  fetch = FetchType.LAZY, fetch = FetchType.EAGER? what is the difference? In which situation you choose which one?
1.Any time you see a @OneToOne, @OneToMany or @ManyToMany annotations, you've got a relationship. What's important to note is that the fetch type should be specified within those annotations, if you don't specify one then it defaults to FetchType.LAZY.
2.Fetch type Eager is essentially the opposite of Lazy, Eager will by default load ALL of the relationships related to a particular object loaded by Hibernate.

### 9.What is the rule of JPA naming convention? Shall we implement the method by ourselves? Could you list some examples?
1.The JPA default table name is the name of the class (minus the package) with the first letter capitalized
2.we've written our implementation, we must register it so that Hibernate knows to use it. Using Spring, this is done by setting the spring.jpa.hibernate.naming.physical-strategy property in our application.properties:
3.create table "PERSON" ("ID" bigint not null, "FIRST_NAME" varchar(255), "LAST_NAME" varchar(255), primary key ("ID"));
4.select "FIRST_NAME" from "PERSON";

