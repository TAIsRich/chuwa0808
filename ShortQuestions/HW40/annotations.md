# Table of Contents
1. [Entity](#Entity)
2. [DAO](#DAO)
3. [Service](#Service)
4. [Contoller](#Contoller)
5. [Other](#Other)

---
## Entity

### @Entity
It identifies that a class is an entity class and and is mapped to a database table.
```java
@Entity
public class Post{
    
}
```

### @Id
It specifies the primary key of an entity.

```java
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;
```

### @GeneratedValue
If we want to automatically generate the primary key value, we can add the `@GeneratedValue` annotation.
it uses four generation types: AUTO, IDENTITY, SEQUENCE and TABLE.
If we don't explicitly specify a value, the generation type defaults to AUTO.

#### GenerationType.AUTO
If we're using the default generation type, the persistence provider will determine values based on the type of the primary key attribute. This type can be numerical or UUID.

#### GenerationType.IDENTITY
This type of generation relies on the IdentityGenerator, which expects values generated by an identity column in the database. This means they are auto-incremented.

#### generator = "sequence-generator"
To use a sequence-based id, Hibernate provides the SequenceStyleGenerator class.

This generator uses sequences if our database supports them. It switches to table generation if they aren't supported.

#### GenerationType.TABLE
The TableGenerator uses an underlying database table that holds segments of identifier generation values.

###  @CreationTimestamp
Helps automatically save the creation timestamp to the column of the table.

---
## DAO 

### @Repository
@Repository’s job is to catch persistence-specific exceptions and re-throw them as one of Spring’s unified unchecked exceptions.
```java
@Repository
public interface PostRepository extends JpaRepository<Post, Long> {

}
```

---
## Service 

### @Service
We mark beans with @Service to indicate that they're holding the business logic. Besides being used in the service layer, there isn't any other special use for this annotation.
```java
@Service
public class PostServiceImpl implements PostService {

}
```

---
## Contoller

### @RestController
1. This annotation is used at the class level and allows the class to handle the requests made by the client.
2. @RestController allows to handle all REST APIs, like CRUD.
```java
@RestController
@RequestMapping("/api/posts")
public class PostController {

}
```

### @RequestMapping

- `@RequestMapping` is used to map HTTP requests to handler methods of MVC and REST controllers.
- The `@RequestMapping` annotation can be applied to class-level and/or method-level in a controller.

### @PostMapping

`@PostMapping` is used for handling the post request that is made by the client containing the JSON data in the header

```java
@PostMapping
public ResponseEntity<PostDto> createPost(@RequestBody PostDto postDto) {
    }
```

### @GetMapping

Annotation for mapping HTTP GET requests onto specific handler methods.

```java
@GetMapping("/{id}")
    public ResponseEntity<PostDto> getPostById(@PathVariable(name = "id") long id) {
        return ResponseEntity.ok(postService.getPostById(id));
    }
```

```java
@GetMapping
    public PostResponse getAllPosts(
            @RequestParam(value = "pageNo", defaultValue = AppConstants.DEFAULT_PAGE_NUMBER, required = false) int pageNo,
            @RequestParam(value = "pageSize", defaultValue = AppConstants.DEFAULT_PAGE_SIZE, required = false) int pageSize,
            @RequestParam(value = "sortBy", defaultValue = AppConstants.DEFAULT_SORT_BY, required = false) String sortBy,
            @RequestParam(value = "sortDir", defaultValue = AppConstants.DEFAULT_SORT_DIR, required = false) String sortDir
    ) {
        return postService.getAllPost(pageNo, pageSize, sortBy, sortDir);
    }
```

### @PutMapping

Annotation for mapping HTTP PUT requests onto specific handler methods.

```java
@PutMapping("/{id}")
    public ResponseEntity<PostDto> updatePostById(@RequestBody PostDto postDto, @PathVariable(name = "id") long id) {
        PostDto postResponse = postService.updatePost(postDto, id);
        return new ResponseEntity<>(postResponse, HttpStatus.OK);
    }
```

### @DeleteMapping

Annotation for mapping HTTP DELETE requests onto specific handler methods.

```java
@DeleteMapping("/{id}")
    public ResponseEntity<String> deletePost(@PathVariable(name = "id") long id) {
        postService.deletePostById(id);
        return new ResponseEntity<>("Post entity deleted successfully.", HttpStatus.OK);
    }
```


---
## Other

### @Autowired

- `@Autowired` allows Spring to resolve and inject collaborating beans into our bean.
- By declaring all the bean dependencies in a Spring configuration file, Spring container can autowire relationships between collaborating beans. This is called Spring bean autowiring.
- After enabling annotation injection, we can use autowiring on properties, setters, and constructors.

```java
@RestController
@RequestMapping("/api/posts")
public class PostController {
    @Autowired
    private PostService postService;
}
```