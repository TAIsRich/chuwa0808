# 2. microservice architeture and components/tools/dependencies

1. Zuul API Gateway will help route the incoming request to different services. Depending on the properties of the Http request or external configurations, Zuul can forward certain calls to specific servers or execute logic for logging.
2. Every service provided need to register within Eureka Service Registry, including the Zuul API, different services, Kafka, etc. Then if the Gateway route the incoming request to service1, then the gateway can find and connect with service1 in Eureka.
3. Every service is stored in it's own docker and every service has it's own database. 
4. Service1 and interact with Service2, but can't modify database2.
5. If a service is too large, then it may need multiple dockers to manage. 
6. How does service1 interact with another service:
- Syncronized method: S1 calls S2's APIs throught S2's serviceId with "**restTemplate**", then it will get a response from S2. But since S2 already registed in Eureka, then S1 can just call S2's serviceId instead of S2's url.
- Asyncronized method: S1 calls S2 throught Kafka. 
    - ex. S1 created an event and send to Kafka, S2 will consume the event. 
7. Spring Cloud Config Server to manage the configuration for different services, just like pom.xml. 

### Component:
1. Spring Cloud -- a collection of extensions for Spring Boot which are useful for cloud applications and for microservices -- a collection of tools;
2. Zuul API Gateway;
3. Eureka Service Registry for service discovery;
- use @EnableEurekaClient;
- Eureka register service by serviceId, monitor service health status, auto-register new services.
- Replication: 
    - what if Eureka is down? 
    - In a distributed system, service discovery is essential for communication between microservices. herefore, service discovery must be implemented in a way that a failure of one server does not cause the entire service discovery to fail.
- Crash detection
    - Eureka expects the microservices to regularly send heartbeats. Eureka dashboard will show if a certain service is up or down.
4. Ribbon Load Balancer;
5. Hystrix Circuit Breaker;
6. Config Server;
7. Kafka
8. Dcoker;

### dependency:
<dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-gateway</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-netflix-eureka-
client</artifactId>
    </dependency>





# 3. What are Resilience patterns? What is circuit breaker?

### Resilience patterns:
1. Time out 
- wait too long for another microservice
2. Fail fast 
- generate an error as quickly as possible
3. Bulkhead 
- Hystrix can use its own thread pool for each type of request.
4. Circuit breaker 
- When a system call results in an error, the circuit breaker is opened and does not allow any calls to pass through.

### Circuit breaker (Hystrix):
- Situlation to use: When S1 calls S2, but s2 is down, then s1 will never get the response from s2 and the waiting time is unlimited. 
- Steps to use Hystrix:
1. add hystrix dependencies
2. add @EnableCircuitBreaker
3. write the testTemplate method to call another service and fallback method
4. add @HystrixCommand(fallback = "fallback_method)
### Load Balancer(Ribbon):
- Balance the workload between different servers. 
- Client Side load balancer - better
- Server Side load balancer

# 4. MicroServices video studing

## Monolithic: 
1. All components, all codes for different functionalities are in a single unit
2. Everything is developed, deployed and scaled as 1 unit
3. All codes must writen in 1 language with 1 technology stack within single run time. 
4. Different teams that work on different functions or parts need to make sure their work will not affect others works.
5. If the code for one function is changed, the whole application will need to rebuild, redeploy.

##  Challenges of monolothic architecture:
1. Applications get larger and more complex, so the functionalities are more tangled into each other.
2. If one part has a sudden usage spike, you can't just scale that specific part, you have to scale the overall services. Which will lead to high cost and less flexibility.
3. If two funtionalities need the same module but different versions, this will be a issue, because 1 applications can only have one dependency for a certain module.
4. Release process takes longer. Since a little change in one part needs the retest for the overall application. 

## What is Microservices:

1. Breakdown one large application into several smaller applications based on domain (DDD - Domain Driven Design) or business functionalities. 
2. Each micro application is independent.

## Communication between different parts:
1. Syncronized: calling api endpoints.
2. Asyncronized: Publisher publish the message into the Message Broker(RabbitMQ) and the Message Broker will forward that message to a related Subscriber. 
3. Service Mesh

## Challenge of Microserbice:
1. Configure the communication bettwen services
- One side is down or having issue, another side is sending request, there will be an unexpected response.
2. Hard to monitor each part since they can be deploy seperately. 

## Tools to solve challenges:
1. Kubernetes: 

    run large microservices applications. 
2. Consul:

    Securely connect and observe your microservices running in any environment. 


## Manage Microservices with git
1. Monorepo -- single repository
2. Polyrepo -- Multi repository


## CI/CD Pipelines(Jenkins)

Jenkins will check if there is any update

# CI - Continuous Integration:
Whenever there is a small increments on code, it will automatically built and tested before merged to the repository. 

Agile methodoloties - Sprint 2 weeks

### Benefits of CI:
1. Improve team productivity and efficienty;
2. Accelerate speed to market;
3. Identify product/market fit;
4. Release higher quality, more stable products;
5. Increase customer satisfaction;
6. Keep developers happy and shipping code.



# CD - Continuous Deployement:
Automated dploy after every code commit that passes the test suite.