###2. Document the microservice architeture and components/tools/dependencies
```
- Zuul API Gateway, all services, and Kafka need to register in Eureka
- Zuul API Gateway rout coming requests to the relative services
- each service is in its own Docker and has its own database
- called service then execute the request and called other services by call http request directly (wait for response) or create an event and send to Kafka (leave it)
- Spring Cloud Config Server to manage the configuration for different services
```
```
Component:
- Spring Cloud
- Zuul API Gateway
- Eureka
- Ribbon Load Balancer
- Hystrix Circuit Breaker
- Cofig server
- kafka
- Docker
```
```
<dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-gateway</artifactId>
</dependency>
<dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-netflix-eureka-
client</artifactId>
    </dependency>
```

###3. What are Resilience patterns? What is circuit breaker?
```
- Time out: A timeout prevents a microservice from waiting too long for another microservice.
- Fail fast: Fail Fast describes a similar pattern. It is better to generate an error as quickly as possible.
- Bulkhead: Hystrix can use its own thread pool for each type of request. For example, a separate thread pool can be set up for each called microservice.
- Circuit breaker: If a system call results in an error, the circuit breaker is opened and does not allow any calls to pass through

circuit breaker:
when the number of failures crosses the threshold number, the circuit breaker trips for a particular time period. 
Then, all the attempts to invoke the remote service will fail within this timeout period. 
After the timeout expires, the circuit breaker allows a limited number of test requests to pass through it. 
If those requests succeed, the circuit breaker resumes back to the normal operation. 
Otherwise, if there is a failure, the timeout period begins again.
```

video watching:
- microservices are split based on business functionalities, one service for one specific job, and it's self-contained and independent
- microservices communicate with each other 
          - through API calls - Synchronouse communication : wait for other service's response
          - vis Message Broker - Asynchronouse communication : user publish message to MB and MB point message to subscriber(service)
          - using Service Mesh - message service to deal with messaging logices
