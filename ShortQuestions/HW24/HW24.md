### 1. remeber pull the new code from that repo
### 2. Explain volatile variables in java? (we also use it in Singleton)
The volatile modifier is used to let the JVM know that a thread accessing the variable must always merge its own private copy of the variable with the master copy in the memory. Accessing a volatile variable synchronizes all the cached copied of the variables in the main memory.
### 3. how to create a new thread(Please also consider Thread Pool case)?
Extends Thread Class
```java
public class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("start new thread using extends thread");
    }
}
Thread t = new MyThread(); // JVM没有创建thread
t.start(); // 此时JVM才创建新的thread
```
Implements Runnable
```java
public class MyRunnable implements Runnable{
    @Override
    public void run() {
        System.out.println("Start new thread using Runnable");
    }
}
Thread t2 = new Thread(new MyRunnable());
```
Implements Callable
```java
public class MyCallable implements Callable<String> {
    @Override
    public String call() throws Exception {
        Thread.sleep(5000);
        return "Start new thread using Callable";
    }
}
```
### 4. Difference between Runnable and Callable
Callable interface and Runnable interface are used to encapsulate tasks supposed to be executed by another thread. However, Runnable instances can be run by Thread class as well as ExecutorService but Callable instances can only be executed via ExecutorService.
```java
public class FactorialTask implements Callable<Integer> {
    int number;
    // standard constructors
    public Integer call() throws InvalidParamaterException {
        int fact = 1;
        // ...
        for(int count = number; count > 1; count--) {
            fact = fact * count;
        }

        return fact;
    }
}
@Test
public void whenTaskSubmitted_ThenFutureResultObtained(){
    FactorialTask task = new FactorialTask(5);
    Future<Integer> future = executorService.submit(task);
 
    assertEquals(120, future.get().intValue());
}
```
### 5. what is the diff between t.start() and t.run()?
start method of thread class is implemented as when it is called a new Thread is created and code inside run() method is executed in that new Thread. While if run method is executed directly than no new Thread is created and code inside run() will execute on current Thread and no multi-threading will take place.
### 6. Which way of creating threads is better: Thread class or Runnable interface?
While implementing Runnable interface we can extends any other class. Hence we are able to use the benefits of Inheritance. Because of the above reasons, implementing Runnable interface approach is recommended than extending Thread class. A user must extend thread class only if it wants to override the other methods in Thread class.
### 7. what is the thread status?
- New Thread: When a new thread is created, it is in the new state. The thread has not yet started to run when the thread is in this state. When a thread lies in the new state, its code is yet to be run and hasn't started to execute.
- Runnable State: A thread that is ready to run is moved to a runnable state. In this state, a thread might actually be running or it might be ready to run at any instant of time. It is the responsibility of the thread scheduler to give the thread, time to run. 

A multi-threaded program allocates a fixed amount of time to each individual thread. Each and every thread runs for a short while and then pauses and relinquishes the CPU to another thread so that other threads can get a chance to run. When this happens, all such threads that are ready to run, waiting for the CPU and the currently running thread lie in a runnable state.
- Blocked/Waiting state: When a thread is temporarily inactive, then it's in one of the following states: 
    - Blocked
    - Waiting
- Timed Waiting: A thread lies in a timed waiting state when it calls a method with a time-out parameter. A thread lies in this state until the timeout is completed or until a notification is received. For example, when a thread calls sleep or a conditional wait, it is moved to a timed waiting state.
- Terminated State: A thread terminates because of either of the following reasons: 
    - Because it exits normally. This happens when the code of the thread has been entirely executed by the program.
    - Because there occurred some unusual erroneous event, like segmentation fault or an unhandled exception.
### 8. difference between wait() and sleep() method
The major difference is that wait() releases the lock while sleep() doesn't release any lock while waiting. wait() is used for inter-thread communication while sleep() is used to introduce a pause on execution, generally.
### 9. What is deadlock?
A condition where two or more threads are blocked forever, waiting for each other. This usually happens when multiple threads need the same locks but obtain them in different orders. Multithreaded Programming in Java suffers from the deadlock situation because of the synchronized keyword.
### 10. how do threads communicate with each other?
Inter-thread communication involves the communication of threads with each other. The three methods that are used to implement inter-thread communication in Java

wait():
This method causes the current thread to release the lock. This is done until a specific amount of time has passed or another thread calls the notify() or notifyAll() method for this object.

notify():
This method wakes a single thread out of multiple threads on the current object's monitor. The choice of thread is arbitrary.

notifyAll():
This method wakes up all the threads that are on the current object's monitor.
### 11. what is join() method?
join() - The current thread invokes this method on a second thread, causing the current thread to block until the second thread terminates.

join(long millisec) - The current thread invokes this method on a second thread, causing the current thread to block until the second thread terminates or the specified number of milliseconds passes.

join(long millisec, int nanos) - The current thread invokes this method on a second thread, causing the current thread to block until the second thread terminates or the specified number of milliseconds + nanoseconds passes.
### 12. what is yield() method
yield() provides a mechanism to inform the 'scheduler' that the current thread is willing to relinquish its current use of processor but it'd like to be scheduled back soon as possible.
### 13. Explain thread pool
A thread pool reuses previously created threads to execute current tasks and offers a solution to the problem of thread cycle overhead and resource thrashing.
### 14. What is Executor Framework in Java, its different types and how to create these executors?
Java provides its own multi-threading framework called the Java Executor Framework.
Some types of Java Executors are listed below:
- SingleThreadExecutor
- FixedThreadPool(n)+
- CachedThreadPool
- ScheduledExecutor
### 15. Difference between shutdown() and shutdownNow() methods of executor
With shutdown , the output is Still waiting after 100ms: calling System. exit(0)... because the running task is not interrupted and continues to run. With shutdownNow , the output is interrupted and Exiting normally
### 16. What is Atomic classes? when do we use it?
Java provides atomic classes such as AtomicInteger, AtomicLong, AtomicBoolean and AtomicReference. Objects of these classes represent the atomic variable of int, long, boolean, and object reference respectively. These classes contain the following methods.
- set(int value): Sets to the given value
- get(): Gets the current value
- lazySet(int value): Eventually sets to the given value
- compareAndSet(int expect, int update): Atomically sets the value to the given updated value if the current value == the expected value
- addAndGet(int delta): Atomically adds the given value to the current value
- decrementAndGet(): Atomically decrements by one the current value
### 17. What is the cocurrent collections?
Concurrent collections in Java are designed with the goal of allowing many threads to access the same data in a synchronized manner.
- It has a unique locking system.
- Thread safety is guaranteed for all concurrent classes.
- The performance of this concurrent classes are much better than that of traditional thread-safe classes.
- We can update data while iterating collection elements, so we won't get a ConcurrentModificationException.
- ConcurrentHashMap
- CopyOnWriteArrayList
- CopyOnWriteArraySet
### 18. what kind of locks you know?
- ReentrantLock
ReentrantLock: condition.await() & condition.signal() & condition.signalAll()
- ReentrantReadWriteLock
Read Lock - If no thread acquired the write lock or requested for it, multiple threads can acquire the read lock.
Write Lock - If no threads are reading or writing, only one thread can acquire the write lock.
- StampedLock
optimistic locking. Most of the time, read operations don't need to wait for write operation completion, and as a result of this, the full-fledged read lock isn't required.
### 19. What is the difference between class lock and object lock?
Class level lock is achieved by keyword "Static Synchronized,where as object level is achieved only by synchronized keyword. Object level lock is achieved to restrict same object to operate through different thread,where as class level lock is achieved to restrict any object to operate.
### 20. What is future and completableFuture?
CompletableFuture implements Future and CompletionStage interfaces and provides a huge set of convenience methods for creating, chaining and combining multiple Futures. It also has a very comprehensive exception handling support.

CompletableFuture is used for asynchronous programming in Java. Asynchronous programming is a means of writing non-blocking code by running a task on a separate thread than the main application thread and notifying the main thread about its progress, completion or failure.

The main advantage of CompletableFuture over normal Future is that CompletableFuture takes advantage of the extremely powerful stream API and gives you callback handlers to chain your tasks, which is absolutely absent if you use normal Future. That along with providing asynchronous architecture, CompletableFuture is the way to go for handling computation heavy map-reduce tasks, without worrying much about application performance.
### 21. what is ThreadLocal?
ThreadLocal provides an easy-to-use API to confine some values to each thread. This is a reasonable way of achieving thread-safety in Java.
The TheadLocal construct allows us to store data that will be accessible only by a specific thread.
### 22. Type the code by your self and try to understand it. (package com.chuwa.tutorial.t08_multithreading)

### 23. write a code to create 2 threads, one thread print 1,3,5,7,9, another thread print 2,4,6,8,10. (solution is in com.chuwa.tutorial.t08_multithreading.c05_waitNotify.OddEventPrinter)
a. One solution use synchronized and wait notify
b. One solution use ReentrantLock and await, signal
```
Thread-0: 1
Thread-1: 2
Thread-0: 3
Thread-1: 4
Thread-0: 5
Thread-1: 6
Thread-0: 7
Thread-1: 8
Thread-0: 9
Thread-1: 10
Process finished with exit code 0
```
### 24. create 3 threads, one thread ouput 1-10, one thread output 11-20, one thread output 21-22. threads run sequence is random. (solution is in com.chuwa.exercise.t08_multithreading.PrintNumber1)
```
Thread-0: 1
Thread-0: 2
Thread-0: 3
Thread-0: 4
Thread-0: 5
Thread-0: 6
Thread-0: 7
Thread-0: 8
Thread-0: 9
Thread-0: 10
Thread-2: 11
Thread-2: 12
Thread-2: 13
Thread-2: 14
Thread-2: 15
Thread-2: 16
Thread-2: 17
Thread-2: 18
Thread-2: 19
Thread-2: 20
Thread-1: 21
Thread-1: 22
Thread-1: 23
Thread-1: 24
Thread-1: 25
Thread-1: 26
Thread-1: 27
Thread-1: 28
Thread-1: 29
Thread-1: 30
```
