2.  Explain volatile variables in java? (we also use it in Singleton)
	Volatile keyword is used to modify the value of a variable by different threads. It is also used to make classes thread safe. It means that multiple threads can use a method and instance of the classes at the same time without any problem. The volatile keyword can be used either with primitive type or objects.

	The volatile keyword does not cache the value of the variable and always read the variable from the main memory. The volatile keyword cannot be used with classes or methods. However, it is used with variables. It also guarantees visibility and ordering. It prevents the compiler from the reordering of code.

3.  how to create a new thread(Please also consider Thread Pool case)?
	- extends Thread {@override run()}
	```
	public class MyThread extends Thread {
			@Override
			public void run() {
				System.out.println("start new thread using extends thread");
			}
		}

	Thread t = new MyThread(); //JVM has not created thread yet
	t.start(); //create new thread
	```
	- implement Runnable{}
	```
	public class MyRunnable implements Runnable {
		@Override
		public void run() {
			System.out.println("...");
		}
	}
	Thread t2 = new Thread(new MyRunnable());
	t.start();
	```
	- implement callable
	```
	public class Mycallable implements Callable<String> {
		@Override
		public String call() throws Exception {
			Thread.sleep(5000);
			return "Start new thread using Callable";
		}
	}
	```
	- threadpool : java.util.concurrent.Executor
	```
	import java.util.concurrent.Executor;
	import java.util.concurrent.Executors;

	public class Demo7 {
	    public static void main(String[] args) {
	        //create thread pool including 5 threads
	        //return ExecutorService
	        Executor threadPool = Executors.newFixedThreadPool(5);
	        for(int i = 0 ;i < 10 ; i++) {
	            threadPool.execute(new Runnable() {
	                public void run() {
	                    System.out.println(Thread.currentThread().getName()+" is running");
	                }
	            });
	        }
	    }
	}
	```
	results:
	pool-1-thread-3 is running
	pool-1-thread-1 is running
	pool-1-thread-4 is running
	pool-1-thread-3 is running
	pool-1-thread-5 is running
	pool-1-thread-2 is running
	pool-1-thread-5 is running
	pool-1-thread-3 is running
	pool-1-thread-1 is running
	pool-1-thread-4 is running

	use ExecutorService threadPool = Executors.newFixedThreadPool(10)
		threadPool.shutdown() to shut down.


4.  Difference between Runnable and Callable
	- runnable cannot return the result of computation, callable return the result of the parallel processing of a task;
	- runnable cannot throw a checked exception, interface can throw 
	- runnavle needs to override run(); callable overrides the call();

5.  what is the diff between t.start() and t.run()?
	- t.start() starts a new thread to excute the task (run())
	- t.run() excute the task in current thread
	

6.  Which way of creating threads is better: Thread class or Runnable interface?
	if need extend other classes, use runnable. if not, use thread class so that we can have a simpler code structure


7. what is the thread status?
	1. NEW
	2. RUNNABLE(READY+ RUNNING)
	3. BLOCKED
	4. WAITING
	5. TIMED_WAITING
	6. TERMINATED

8.  difference between wait() and sleep() method？
	- t.sleep(millis) -> TIMED_WAITING, cannot be wocken up mannually
	- o.wait() -> release obj lock, wake up by another thread calling notify,notify all

9.  What is deadlock?
	It's a situation where 2 or more threads are blocked forever. 

10. how do threads communicate with each other?
	- The first is through commonly shared data. All the threads in the same program share the same memory space. If an object is accessible to various threads then these threads share access to that object's data member and thus communicate each other.
	- The second way for threads to communicate is by using thread control methods. There are such three methods by which threads communicate for each other : 
		suspend ( ); resume ( ); join ( );
	- The third way for threads to communicate is the use of three methods; 
		wait(), notify(), and notifyAll();

11. what is join() method?
	When we invoke the join() method on a thread, the calling thread goes into a waiting state. It remains in a waiting state until the referenced thread terminates.

12. what is yield() method
	yield() provides a mechanism to inform the “scheduler” that the current thread is willing to relinquish its current use of processor but it'd like to be scheduled back soon as possible.


13. Explain thread pool
	- When we use a thread pool, we write our concurrent code in the form of parallel tasks and submit them for execution to an instance of a thread pool. 
	a)	manages a set of anonymous threads that perform work on request
	b)	reduce the expense to create a new thread


14. What is Executor Framework in Java, its different types and how to create these 
executors?
	- It contains a bunch of components to efficiently manage multiple threads. It was released with the JDK 5 which is used to run the Runnable objects without creating new threads every time and also mostly re-using the already created threads.
	- types:
		1. SingleThreadExecutor: by calling the static newSingleThreadExecutor() method of the Executors class
	  	2. FixedThreadPool: The tasks submitted to the executor are executed by the n threads and if there is more task they are stored on a LinkedBlockingQueue. It uses Blocking Queue.
	  	3. CachedThreadPool: Creates a thread pool that creates new threads as needed, but will reuse previously constructed threads when they are available. Calls to execute will reuse previously constructed threads if available. If no existing thread is available, a new thread will be created and added to the pool. It uses a SynchronousQueue queue.
	  	4. ScheduledExecutor :Scheduled executors are based on the interface ScheduledExecutorService which extends the ExecutorService interface. This executor is used when we have a task that needs to be run at regular intervals or if we wish to delay a certain task. 


15. Difference between shutdown() and shutdownNow() methods of executor
	- shutdown() can safely shutdown a thread pool.  After the shutdown() method is called, the thread pool is completely shutdown after executing the tasks in progress and the tasks waiting in the queue. While shutdownNow() close the thread pool immediately. 

16. What is Atomic classes? when do we use it?
	- The atomic classes provide a lock-free and thread-safe environment or programming on a single variable. All the atomic classes have the get() and set() methods that work on the volatile variable.


17.  What is the cocurrent collections?
	- they are a bunch of thread safe collections: 
		ArrayList - CopyOnWriteArrayList
		HashMap   - ConcurrentHashMap
		HashSet   - CopyOnWriteArraySet
		ArrayDeque/LinkedList  - ArrayBlockingQueue/LinkedBlockingQueue


18. what kind of locks you know?
	Synchronized, ReentrantLock, ReadWriteLock, StampedLock...


19. What is the difference between class lock and object lock?
		1. Object Level Locks − It can be used when you want non-static method or non-static block of the code should be accessed by only one thread.
		Class Level locks − It can be used when we want to prevent multiple threads to enter the synchronized block in any of all available instances on runtime. It should always be used to make static data thread safe
		2. Object lock: used to make non-static data thread safe
		   Class lock: static data 
		3. Object lock: every object have their own lock
		   CLass lock : only one lock available


20. What is future and completableFuture?
	- future: an interface belongs to java.util.concurrent package. used to represent the result of an asynchronous computation.The interface provides the methods to check if the computation is completed or not, to wait for its completion, and to retrieve the result of the computation.
	- completableFuture： When the work is complete, it notifies the main thread (as well as whether the work was completed or failed).


21. what is ThreadLocal?
	The TheadLocal construct allows us to store data that will be accessible only by a specific thread. It is another way to achieve thread-safety apart from writing immutable classes.
