####1. remeber pull the new code from that repo
####2. Explain volatile variables in java? (we also use it in Singleton)

The volatile modifier is used to let the JVM know that a thread accessing the variable must always merge its own private copy of the variable with the master copy in the memory.

####3. how to create a new thread(Please also consider Thread Pool case)?

* Extends Thread class. Create a thread by a new class that extends Thread class and create an instance of that class.
* To use thread pools, we first create a object of ExecutorService and pass a set of tasks to it. ThreadPoolExecutor class allows to set the core and maximum pool size. The runnables that are run by a particular thread are executed sequentially

####4. Difference between Runnable and Callable

* Callable interface - throws the checked exception and returns the result. 
* Runnable interface - shows the result or throws an exception, but does not do both.

####5. what is the diff between t.start() and t.run()?

* t.start() - starts a new thread and execute t.run() in new thread
* t.run() - runs the task in the current thread.

####6. Which way of creating threads is better: Thread class or Runnable interface?

* If we want override other methods in the Thread class, we use the Thread class.
* If we want to extend other class, we use Runnable interface.

####7. what is the thread status?

* New
* Runnable
* Running
* Blocked (Non-runnable state)
* Dead

####8. difference between wait() and sleep() method

* wait() releases the lock, used for inter-thread communication 
* sleep() doesn't release any lock, used to introduce a pause on execution

####9. What is deadlock?

Deadlock in Java means that two or more threads are blocked forever, waiting for each other.

One example is a situation in which a process is waiting for a rescource that is held by another process, while the other process is also waiting for a resouce that can only be released when the first process finishes.

####10. how do threads communicate with each other?

wait(), notify(), and notifyAll()

####11. what is join() method?

The join() method in Java is provided by the java.lang. Thread class that permits one thread to wait until the other thread to finish its execution.

####12. what is yield() method

A yield() method is a static method of Thread class and it can stop the currently executing thread and will give a chance to other waiting threads of the same priority.

####13. Explain thread pool

A thread pool reuses previously created threads to execute current tasks and offers a solution to the problem of thread cycle overhead and resource thrashing

####14. What is Executor Framework in Java, its different types and how to create these executors?

* Java executor framework (java.util.concurrent.Executor), released with the JDK 5 is used to run the Runnable objects without creating new threads every time and mostly re-using the already created threads. 
  * SingleThreadExecutor
  * FixedThreadPool(n)+
  * CachedThreadPool
  * ScheduledExecutor

####15. Difference between shutdown() and shutdownNow() methods of executor

* shutdown() tells the executor to stop accepting new tasks, but the accepted tasks will continue running.
* shutdownNow() will interrupt all running tasks as well as stop accpeting new tasks.

####16. What is Atomic classes? when do we use it?

* Atomic classes such as AtomicInteger, AtomicLong, AtomicBoolean are classes that support atomic operations on single variables. We use set to change the value of atomic vaiables and get to retrieve the value of atomic variables.

####17. What is the cocurrent collections?

* It is a set of collections APIs that are designed and optimized specifically for synchronized multithreaded access.

####18. what kind of locks you know?

ReentrantLock, ReadWriteLock, StampedLock.

####19. What is the difference between class lock and object lock?

* A class is just an object. When you use class lock, you're ensuring that every synchronized code block uses the same lock.
* With object locks, we can create many locks to be used in any place we want.

####20. What is future and completableFuture?

* Future represents the result of an asynchronous computation executed by a executor. When we call get() to a future object, the main thread will block until the task is finished.
* CompletableFuture is an extension of Future, it provides non-blocking methods such as thenAccept, and exceptionally.

####21. what is ThreadLocal?

ThreadLocal provides several API to make a object visible in a single threads. We can use set and get to store and retrieve values.

####22. Type the code by your self and try to understand it. (package
* com.chuwa.tutorial.t08_multithreading)
####23. write a code to create 2 threads, one thread print 1,3,5,7,9, another thread print 2,4,6,8,10. (solution is in com.chuwa.tutorial.t08_multithreading.c05_waitNotify.OddEventPrinter)
1. One solution use synchronized and wait notify

```Java
 public class ThreadDemo {

        public static void main(String[] args) {
            // TODO Auto-generated method stub
            Demo demo = new Demo();
            Thread t1 = new Thread(demo);
            Thread t2 = new Thread(demo);
            t1.start();
            t2.start();
        }
        static class Demo implements Runnable{
            int a = 1;
            @Override
            public void run() {
                // TODO Auto-generated method stub
                synchronized(this) {
                    while(a <= 10) {
                        System.out.println(a);
                        notify();
                        a++;
                        try {
                            wait();
                        } catch (InterruptedException e) {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                        }
                    }
                }
            }

        }
    }
```

2. One solution use ReentrantLock and await, signal

```java
public class ThreadDemo {

        public static void main(String[] args) {
            // TODO Auto-generated method stub
            Demo demo = new Demo();
            Thread t1 = new Thread(demo);
            Thread t2 = new Thread(demo);
            t1.start();
            t2.start();
        }
        static class Demo implements Runnable{
            private final ReentrantLock lock = new ReentrantLock();
            int a = 1;
            @Override
            public void run() {
                // TODO Auto-generated method stub
                while(a <= 10) {
                    lock.lock();
                    System.out.println(a);
                    a++;
                    lock.unlock();
                }
            }

        }
    }
```

####24. create 3 threads, one thread ouput 1-10, one thread output 11-20, one thread output 21-22. threads run sequence is random. (solution is in com.chuwa.exercise.t08_multithreading.PrintNumber1)

```java
public class PrintNumber1 {
    private static int n = 1;

    public static void main(String[] args) {
        Thread t1 = new Thread(() -> printNumber());
        Thread t2 = new Thread(() -> printNumber());
        Thread t3 = new Thread(() -> printNumber());

        t1.start();
        t2.start();
        t3.start();
    }

    private static synchronized void printNumber() {
        int count = 10;
        while (count-- > 0) {
            System.out.println(Thread.currentThread().getName() + ": " + n++);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        PrintNumber1.class.notifyAll();
    }
}
```