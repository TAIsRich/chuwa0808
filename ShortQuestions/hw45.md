### 2. What is HTTP Session?
        
1. The client establishes a TCP connection (or the appropriate connection if the transport layer is not TCP).
2. The client sends its request, and waits for the answer.
3. The server processes the request, sending back its answer, providing a status code and appropriate data.

- Since the Http is stateless, in order to work with a request to any other request, we need a way to store user date between Http request. The solution is to store that data server side, give it an "id", and let the client only know(and pass back at any http request) that id, which the session is implemented.
  
- HTTP sessions is an industry standard feature that allows Web servers to maintain user identity and to store user-specific data during multiple request/response interactions between a client application and a Web application. HTTP sessions preserves:
  - Information about the session itself (session identifier, creation time, time last accessed, etc.)
  - Contextual information about the user (client login state, for example, plus whatever else the Web application needs to save)
### 3. What is Cookie?
- An HTTP cookie (web cookie, browser cookie) is a small piece of data that a server sends to a user's web browser. The browser may store the cookie and send it back to the same server with later requests. Typically, an HTTP cookie is used to tell if two requests come from the same browser—keeping a user logged in, for example. It remembers stateful information for the stateless HTTP protocol.
- Cookies were once used for general client-side storage. While this made sense when they were the only way to store data on the client, modern storage APIs are now recommended. Cookies are sent with every request, so they can worsen performance (especially for mobile data connections).
### 4. What is the difference between Session and Cookie?
- Session: A session is used to save information on the server momentarily so that it may be utilized across various pages of the website. It is the overall amount of time spent on an activity. The user session begins when the user logs in to a specific network application and ends when the user logs out of the program or shuts down the machine. 
- Cookie: A cookie is a small text file that is saved on the user’s computer. The maximum file size for a cookie is 4KB. It is also known as an HTTP cookie, a web cookie, or an internet cookie. When a user first visits a website, the site sends data packets to the user’s computer in the form of a cookie.
- Cookies are client-side files on a local computer that hold user information.	Sessions are server-side files that contain user data.
- It can only store a certain amount of info.	It can hold an indefinite quantity of data.
- The browser’s cookies have a maximum capacity of 4 KB.	We can keep as much data as we like within a session, however there is a maximum memory restriction of 128 MB that a script may consume at one time.
- Because cookies are kept on the local computer, we don’t need to run a function to start them.	To begin the session, we must use the session start() method.
- Cookies stored data in text file.	Session save data in encrypted form.
- Cookies stored on a limited data.	Session stored a unlimited data.
### 5. How do we use session and cookie to keep user information across the application?
- By using session cookies
- A website itself cannot track a user’s movement on its webpage and treats each new page request as a new request from a new user. Session cookies allow websites to remember users within a website when they move between web pages. These cookies tell the server what pages to show the user so the user doesn’t have to remember where they left off or start navigating the site all over again. Therefore, without session cookies, websites have no memory. Session cookies are vital for user experience on online shops and websites when the functionalities depend on users’ activities.
- The session cookie is a server-specific cookie that cannot be passed to any machine other than the one that generated the cookie. The server creates a “session ID” which is a randomly generated number that temporarily stores the session cookie. This cookie stores information such as the user’s input and tracks the movements of the user within the website. There is no other information stored in the session cookie.
- Session cookies are cookies that last for a session. A session starts when you launch a website or web app and ends when you leave the website or close your browser window. Session cookies contain information that is stored in a temporary memory location which is deleted after the session ends. Unlike other cookies, session cookies are never stored on your device. Therefore, they are also known as transient cookies, non-persistent cookies, or temporary cookies.
- We can use shared cache like Redis
### 6. What is the spring security filter?
- Spring Security in the web tier (for UIs and HTTP back ends) is based on Servlet Filters
- The client sends a request to the application, and the container decides which filters and which servlet apply to it based on the path of the request URI. At most, one servlet can handle a single request, but filters form a chain, so they are ordered. In fact, a filter can veto the rest of the chain if it wants to handle the request itself. A filter can also modify the request or the response used in the downstream filters and servlet.
### 7. Do you use any Encoder to encode Password?
- There are many ways to encode a password - encryption, hashing, salting, slow hashing...
1. BCryptPasswordEncoder: it relies on the BCrypt algorithm to hash passwords
   - A constructor parameter to keep an eye out for here is the strength. By default, it's set to 10, though it can go up to 32 - The larger the strength is, the more work it takes to compute the hash. This "strength" is actually the number of iterations (210) used.
   - Another optional argument is SecureRandom. SecureRandom is an object containing a random number that's used to randomize the generated hashes:
```
BCryptPasswordEncoder()
BCryptPasswordEncoder(int strength)
BCryptPasswordEncoder(int strength, java.security.SecureRandom random)

BCryptPasswordEncoder encoder = new BCryptPasswordEncoder(12); // Strength set as 12
String encodedPassword = encoder.encode("UserPassword");

$2a$12$DlfnjD4YgCNbDEtgd/ITeOj.jmUZpuz1i4gt51YzetW/iKY2O3bqa
"$2a$" The version of BCrypt
"12$" is the cost factor representing 2^10 iterations of the key derivaation
The first 22 characters aferwards are the salt of the password
The rest is the hashed password itself
```

2. Pbkdf2PasswordEncoder: relies on the PBKDF2 algorithm to hash passwords.
   - Secret - Key used during the encoding process. As the name implies, it should be secret.
   - Iteration - The number of iterations used to encode the password, the documentation advises as many iterations for your system to take 0.5 seconds to hash.
   - Hash Width - The size of the hash itself.

```
// constructors
Pbkdf2PasswordEncoder()
Pbkdf2PasswordEncoder(java.lang.CharSequence secret)
Pbkdf2PasswordEncoder(java.lang.CharSequence secret, int iterations, int hashWidth)

Pbkdf2PasswordEncoder encoder = new Pbkdf2PasswordEncoder("secret", 10000, 128);
String encodedPassword = encoder.encode("UserPassword");

zFRsnmzHKgWKWwgCBM2bfe0n8E9EZRsCtngcSBewray7VfaWjeYizhCxCkwBfjBMCGpY1aN0YdY7iBNmyiT+7bdfGfCeyUdGnTUVxV5doJ5UC6m6mj2n+60Bj8jGBMs2KIMB8c/zOZGLnlyvlCH39KB5xewQ22enLYXS5S8TlwQ
```

3. SCryptPasswordEncoder: it relies on the SCrypt algorithm to hash passwords.
    - CPU cost - CPU Cost of the algorithm, the default is 214 - 16348. This int must be a power of 2.
    - Memory cost - By default is 8
    - Parallelization - Although formally present, SCrypt doesn't take advantage of parallelization.
    - Key Length - Defines the length of the output hash, by default, it's set to 32.
    - Salt Length - Defines the length of the salt, the default value is 64.
   
```
// constructors
SCryptPasswordEncoder()
SCryptPasswordEncoder(int cpuCost, int memoryCost, int parallelization, int keyLength, int saltLength)

SCryptPasswordEncoder encoder = new SCryptPasswordEncoder();
String encodedPassword = encoder.encode("UserPassword");
```
- Salting : To combat the appearance of rainbow tables, developers started adding a random sequence of characters to the beginnings of the hashed passwords. While it wasn't a complete game changer, it at least slowed down attackers since they couldn't find hashed versions of passwords in public rainbow tables. So if you had a common password like "123456", the salt would prevent your password from being identified immediately since it was changed before hashing.
### 8. What is UserDetailService? AuthenticationProvider?AuthenticationManager? AuthenticationFilter?(把这⼏个名字看熟悉也⾏)
- The UserDetailsService interface is used to retrieve user-related data. It has one method named loadUserByUsername() which can be overridden to customize the process of finding the user. It is used by the DaoAuthenticationProvider to load details about the user during authentication.
- Authentication request is processed by an AuthenticationProvider, and a fully authenticated object with full credentials is returned. More custom scenarios will still need to access the full Authentication request to be able to perform the authentication process. For example, when authenticating against some external, third party service (such as Crowd), both the username and password from the authentication request will be necessary. For these more advanced scenarios, we'll need to define a custom Authentication Provider:
- The AuthenticationManager is really just a container for authentication providers, giving a consistent interface to them all. In most cases, the default AuthenticationManager is more than sufficient.
- An authentication filter is a component that authenticates an HTTP request. Authentication filters let you set an authentication scheme for individual controllers or actions. That way, your app can support different authentication mechanisms for different HTTP resources.
### 9. What is the disadvantage of Session? how to overcome the disadvantage?
- Performance overhead in case of large volumes of data/user, because session data is stored in server memory
- Overhead involved in serializing and de-serializing session data, because in the case of StateServer and SQLServer session modes, we need to serialize the objects before storing them.

- By using cookie
### 10. What is JWT?
- JSON Web Token (JWT) is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the HMAC algorithm) or a public/private key pair using RSA or ECDSA.
- Although JWTs can be encrypted to also provide secrecy between parties, we will focus on signed tokens. Signed tokens can verify the integrity of the claims contained within it, while encrypted tokens hide those claims from other parties. When tokens are signed using public/private key pairs, the signature also certifies that only the party holding the private key is the one that signed it.
### 11. decribe how do JWT work(slides ⾥有图， 26页)
- A JWT is a string made up of three parts, separated by dots (.), and serialized using base64. In the most common serialization format, compact serialization, the JWT looks something like this: xxxxx.yyyyy.zzzzz.
- Once decoded, you will get two JSON strings:
   - The header and the payload.
   - The signature.
- The payload contains the claims. This is displayed as a JSON string, usually containing no more than a dozen fields to keep the JWT compact. This information is typically used by the server to verify that the user has permission to perform the action they are requesting.
- The signature ensures that the token hasn’t been altered. The party that creates the JWT signs the header and payload with a secret that is known to both the issuer and receiver, or with a private key known only to the sender. When the token is used, the receiving party verifies that the header and payload match the signature.
### 12. how to get value from application.properties?
- We can use the @Value annotation and access the property in whichever Spring bean we are using
```
@Value("${userBucket.path}")
private String userBucketPath;
```
### 13. What is the role of configure(HttpSecurity http) and configure(AuthenticationManagerBuilder auth)?
- configure(AuthenticationManagerBuilder) is used to establish an authentication mechanism by allowing AuthenticationProviders to be added easily: e.g. The following defines the in-memory authentication with the in-built 'user' and 'admin' logins.
```
public void configure(AuthenticationManagerBuilder auth) {
    auth
        .inMemoryAuthentication()
        .withUser("user")
        .password("password")
        .roles("USER")
    .and()
        .withUser("admin")
        .password("password")
        .roles("ADMIN","USER");
}
```
- configure(HttpSecurity) allows configuration of web based security at a resource level, based on a selection match - e.g. The example below restricts the URLs that start with /admin/ to users that have ADMIN role, and declares that any other URLs need to be successfully authenticated.
```
protected void configure(HttpSecurity http) throws Exception {
    http
        .authorizeRequests()
        .antMatchers("/admin/**").hasRole("ADMIN")
        .anyRequest().authenticated()
}
```
### 14. What is Spring security authentication and authorization?
- Authentication: First off, if you are running a typical (web) application, you need your users to authenticate. That means your application needs to verify if the user is who he claims to be, typically done with a username and password check.
```
User: "I’m the president of the United States. My username is: potus!"

Your webapp: "Sure sure, what’s your password then, Mr. President?"

User: "My password is: th3don4ld".

Your webapp: "Correct. Welcome, Sir!"
```
- Authorization: In simpler applications, authentication might be enough: As soon as a user authenticates, she can access every part of an application. But most applications have the concept of permissions (or roles). Imagine: customers who have access to the public-facing frontend of your webshop, and administrators who have access to a separate admin area. Both type of users need to login, but the mere fact of authentication doesn’t say anything about what they are allowed to do in your system. Hence, you also need to check the permissions of an authenticated user, i.e. you need to authorize the user.
```
User: "Let me play with that nuclear football…"

Your webapp: "One second, I need to check your permissions first...yes Mr. President, you have the right clearance level. Enjoy."

User: "What was that red button again…??"
```
### 15. Reading, 泛读⼀下即可，⾃⼰觉得是重点的，可以多看两眼。https://www.interviewbit.com/spring-security-interview-questions/#is-security-a-cross-cutting-concern
    a. 1-12
    b. 17 - 30