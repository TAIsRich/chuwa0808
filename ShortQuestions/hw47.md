1. List all of the new learned annotations to your annotations.md 
2. what is selenium(YouTube)?
 * Selenium is an open source umbrella project for a range of tools and libraries aimed at supporting browser automation. It provides a playback tool for authoring functional tests across most modern web browsers, without the need to learn a test scripting language.

3. what is cucumber(youtueb)?
 * Cucumber is a software tool that supports behavior-driven development. Central to the Cucumber BDD approach is its ordinary language parser called Gherkin. It allows expected software behaviors to be specified in a logical language that customers can understand.

4. what is JMeter(youtube)?
 * Apache JMeter is an Apache project that can be used as a load testing tool for analyzing and measuring the performance of a variety of services, with a focus on web applications.

5. what is unit-test?
 * Unit Testing is defined as a type of software testing where individual components of a software are tested. Unit Testing of the software product is carried out during the development of an application. An individual component may be either an individual function or a procedure.

6. What is the lifecircle of Junit?
 * In JUnit 5, the test lifecycle is driven by four primary annotations i.e. @BeforeAll, @BeforeEach, @AfterEach and @AfterAll. Along with it, each test method must be marked with @Test annotation from package org.junit.jupiter.api.

 * Normally, a test class contains multiple test methods. JUnit manages the execution of each test method in form of a lifecycle. The complete lifecycle of a test case can be seen in three phases with the help of annotations.

 1. **Setup:** This phase puts the the test infrastructure in place. JUnit provides class level setup (@BeforeAll) and method level setup (@BeforeEach). Generally, heavy objects like databse comnections are created in class level setup while lightweight objects like test objects are reset in the method level setup.
 2. **Test Execution:** In this phase, the test execution and assertion happen. The execution result will signify a success or failure.
 3. **Cleanup:** This phase is used to cleanup the test infrastructure setup in the first phase. Just like setup, teardown also happen at class level (@AfterAll) and method level (@AfterEach). Called to do any required post processing after a test. Examples include cleaning up of database tables and closing database connections.

7. Is @BeforeAll method should be Class level(static)? 
 * @BeforeAll and @AfterAll annotations – clear by their name – should be called only once in the entire tests execution cycle. So they must be declared static. @BeforeAll annotated method being a class level method, it gets called even before the constructor.

8. What is Mockito? and what is its limitations?
 * Mockito is a JAVA-based library used for unit testing applications. This open-source library plays an important role in automated unit tests for the purpose of test-driven development or behavior-driven development. It uses a mock interface to add dummy functionality in the unit testing. It also uses Java reflection to create mock objects for an interface to test it.

 * The primary objective of using the Mockito framework is to simplify the development of a test by mocking external dependencies and using them in the test code. And as a result, Mockito provides a simpler test code that is easier to understand, more readable, and modifiable. Mockito can also be used with other testing frameworks like JUnit and TestNG. 

 * Some limitations of the mockito are: 
   1. It cannot mock constructors or static methods.
   2. It requires Java version 6 plus to run.
   3. It also cannot mock equals(), hashCode() methods.
   4. VM mocking is only possible on VMs that are supported by Objenesis.

9. What is @Mock and what is @InjectMocks?
 * @Mock creates a mock, and @InjectMocks creates an instance of the class and injects the mocks that are created with the @Mock annotations into this instance. 

   1. @Mock creates a mock.	
   1. @InjectMocks creates an instance of the class and injects the mocks that are created with the @Mock annotations into this instance.
   2. @Mock is used to create mocks that are needed to support the testing of the class to be tested. 
   2. @InjectMocks is used to create class instances that need to be tested in the test class.
   3. Annotated class to be tested dependencies with @Mock annotation.	
   3. @InjectMocks is used when the actual method body needs to be executed for the given class.
   4. We must define the when-thenReturn methods for mock objects and which class methods will be invoked during actual test execution.	
   4. Use @InjectMocks when we need all internal dependencies initialized with mock objects to work the method correctly.

10. What is the stubbing?
  * A stub is a fake class that comes with preprogrammed return values. It's injected into the class under test to give you absolute control over what's being tested as input. A typical stub is a database connection that allows you to mimic any scenario without having a real database.

  * Stub: a dummy piece of code that lets the test run, but you don't care what happens to it. Substitutes for real working code. Mock: a dummy piece of code that you verify is called correctly as part of the test. Substitutes for real working code.

11. what is Mockito ArgumentMatchers
  * Argument matchers are mainly used for performing flexible verification and stubbing in Mockito. It extends ArgumentMatchers class to access all the matcher functions. Mockito uses equal() as a legacy method for verification and matching of argument values. In some cases, we need more flexibility during the verification of argument values, so we should use argument matchers instead of equal() method. The ArgumentMatchers class is available in org.mockito package.

12. what is Hamcrest Matchers?
  * Hamcrest is a popular framework that help us to create the matcher objects. It is used for writing software tests and also performs unit testing in Java programming language. Hamcrest is mainly used with other unit testing frameworks like JUnit, jMockit, Mockito, etc. 

  * Hamcrest target is to make your tests easier to write and read. For this, it provides additional matcher classes which can be used in test. To use Hamcrest matchers in your test you use the assertThat statement followed by one or several matchers.

  `AllOf` Calculates the logical conjunction of multiple matchers. Examined object must match ALL of the specified matcher.
  ```assertThat(“myString”, allOf(startsWith(“my”), containsString(“Str”)))```

  `AnyOf` Calculates the logical disjunction of multiple matchers. Examined object matches ANY of the specified matchers.
  ```assertThat(“myString”, allOf(startsWith(“your”), containsString(“Str”)))```

  `DescribedAs`	Adds a description to a Matcher.
  ```assertThat(“Sunday”, describedAs(“Sunday is not Saturday.”, is(not(“Saturday”))));```

  `Is` Decorates another Matcher, retaining its behavior. In other words it checks given objects equality. Is method allows tests to be more meaningful/expressive.
  ```assertThat(cheese, is(equalTo(smelly)))``` instead of: `assertThat(cheese, equalTo(smelly))`

  `IsAnything` A matcher that always returns true.
  ```assertThat(“Onur”, is(anything(“Bla Bla Bla”)));```

  `IsEqual` It checks given objects equality.
  `assertThat("str", equalTo("str "));` or `assertThat("str ", is(equalTo("str ")));`

  `IsInstanceOf` Tests whether the value is an instance of a class.
  `assertThat(myInstanceTest, instanceOf(InstanceTest.class));`

  `IsNot<T>` Creates a matcher that wraps an existing matcher, but inverts the logic by which it will match.
  `assertThat(“onur”, is(not(equalTo(“mike”))));`

13. do you know @spy? what is difference between @spy and @Mock? 
  * Both can be used to mock methods or fields. The difference is that in mock, you are creating a complete mock or fake object while in spy, there is the real object and you just spying or stubbing specific methods of it.

  * When using mock objects, the default behavior of the method when not stub is do nothing. Simple means, if its a void method, then it will do nothing when you call the method or if its a method with a return then it may return null, empty or the default value.

  * While in spy objects, of course, since it is a real method, when you are not stubbing the method, then it will call the real method behavior. If you want to change and mock the method, then you need to stub it.

  * If you want to be safe and avoid calling external services and just want to test the logic inside of the unit, then use mock. If you want to call external service and perform calling of real dependency, or simply say, you want to run the program as it is and just stub specific methods, then use spy.

14. briefly reading this articles
a. https://www.javatpoint.com/examples-of-mockito-and-junit-in-eclipse-ide
b. https://www.javatpoint.com/junit-tutorial
c. https://www.javatpoint.com/testng-tutorial
d. https://www.javatpoint.com/jmeter-tutorial