### 2. what is selenium(YouTube)?
- Selenium is a free (open source) automated testing suite for web applications across different browsers and platforms
- Selenium consist of four components: Selenium(IDE), Selenium(Remote Control), WebDriver, and Selenium Grid
- User-behavior simulation
- You can use multiple programming languages like Java, C#, Python etc to create Selenium Test Scripts. Testing done using the Selenium testing tool is usually referred to as Selenium Testing. Selenium Software is not just a single tool but a suite of software, each piece catering to different Selenium QA testing needs of an organization. Here is the list of tools
### 3. what is cucumber(youtueb)?
- Cucumber is a testing tool that supports Behavior Driven Development (BDD). It offers a way to write tests that anybody can understand, regardless of their technical knowledge. In BDD, users (business analysts, product owners) first write scenarios or acceptance tests that describe the behavior of the system from the customer’s perspective, for review and sign-off by the product owners before developers write their codes. Cucumber framework uses Ruby programming language.
- Given, When, and Then
### 4. what is JMeter(youtube)?
- Apache JMeter is a testing tool used for analyzing and measuring the performance of different software services and products. It is a pure Java open source software used for testing Web Application or FTP application.
- It is used to execute performance testing, load testing and functional testing of web applications. JMeter can also simulate a heavy load on a server by creating tons of virtual concurrent users to web server.
### 5. what is unit-test?
- A unit test is a way of testing a unit - the smallest piece of code that can be logically isolated in a system. In most programming languages, that is a function, a subroutine, a method or property. The isolated part of the definition is important. In his book "Working Effectively with Legacy Code", author Michael Feathers states that such tests are not unit tests when they rely on external systems: “If it talks to the database, it talks across the network, it touches the file system, it requires system configuration, or it can't be run at the same time as any other test."
- Unit testing involves the testing of each unit or an individual component of the software application.
- The purpose is to validate that each unit of the software code performs as expected.
- Unit testing is done during develpment of an application by the developers
- Unit may be a anindividual function, method, procedure, module and object.
- Even though we have QA, usually the developer who developed the new code write unit test by themselves.
### 6. What is the lifecycle of Junit?
- The complete lifecycle of a test case can be seen in three phases with the help of annotations.
  - Setup: This phase puts the the test infrastructure in place. JUnit provides class level setup (@BeforeAll) and method level setup (@BeforeEach). Generally, heavy objects like databse comnections are created in class level setup while lightweight objects like test objects are reset in the method level setup.
  - Test Execution: In this phase, the test execution and assertion happen. The execution result will signify a success or failure.
  - Cleanup: This phase is used to cleanup the test infrastructure setup in the first phase. Just like setup, teardown also happen at class level (@AfterAll) and method level (@AfterEach).
### 7. Is @BeforeAll method should be Class level(static)?
- @BoforeAll is used to signal that the annotated method should be executed before all the @Test, @RepeatedTest, @ParameterizedTest, and @TestFactory methods in the current class.
- By default, the test methods will be executed in the same thread as @BeforeAll annotated method.
   - @BeforeAll annotated method MUST be a static method in the test class.
### 8. What is Mockito? and what is its limitations?
- Mockito is a Java-based mocking framework used for unit testing of Java application. Mockito plays a crucial role in developing testable applications. Mockito was released as an open-source testing framework under the MIT (Massachusetts Institute of Technology) License. It internally uses the Java Reflection API to generate mock objects for a specific interface. Mock objects are referred to as the dummy or proxy objects used for actual implementations.
- The main purpose of using the Mockito framework is to simplify the development of a test by mocking external dependencies and use them in the test code. As a result, it provides a simpler test code that is easier to read, understand, and modify. We can also use Mockito with other testing frameworks like JUnit and TestNG.
Limitations:
- Its inability to mock static methods.
- Constructors, private methods and final classes cannot be mocked.
### 9. What is @Mock and what is @InjectMocks?
What is a Mock:
- It is important to understand the difference between a mock and an object. An object is an actual instance of a class and any method invoked using object reference will execute the method body defined in the class file.
- A mock object is a proxy interface to hide an underlying dependency with cannot be tested in a test environment e.g. database, network locations etc. A method invoked using mocked reference does not execute the actual method body defined in the class file, rather the method behavior is configured using when(...).thenReturn(...) methods.
  - In a junit test, we create objects for the class which need to be tested and its methods to be invoked.
  - We create mocks for the dependencies which will not be present in the test environment and objects are dependent on it to complete the method call.

Difference between @Mock and @InjectMocks:
- In mockito-based junit tests, @Mock annotation creates mocks and @InjectMocks creates actual objects and injects mocked dependencies into it.
   - Use @InjectMocks to create class instances that need to be tested in the test class. We call it ‘code under test‘ or ‘system under test‘.
   - Use @InjectMocks when actual method body needs to be executed for a given class.
   - Use @InjectMocks when we need all or few internal dependencies initialized with mock objects to work method correctly.
   - Use @Mock to create mocks that are needed to support the testing of SUT.
   - We must define the when(...).thenReturn(...) methods for mock objects whose class methods will be invoked during actual test execution.

- Inorder to understand the difference between @Mock and @InjectMocks with an example. In this example, we have a class MainClass that has a method save().
- MainClass has a dependency on DatabaseDAO and NetworkDAO. When we call MainClass.save() method, it internally calls save methods of both dependent objects.
- System Under Test
```
public class MainClass {

	DatabaseDAO database;
	NetworkDAO network;

	//Setters and getters

	public boolean save(String fileName)
	{
		database.save(fileName);
		System.out.println("Saved in database in Main class");

		network.save(fileName);
		System.out.println("Saved in network in Main class");

		return true;
	}
}
public class DatabaseDAO {
	public void save(String fileName) {
		System.out.println("Saved in database");
	}
}
public class NetworkDAO {
	public void save(String fileName) {
		System.out.println("Saved in network location");
	}
}
```

- Unit Test:
```
import static org.junit.Assert.assertEquals;

import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

public class ApplicationTest
{
	@InjectMocks
	MainClass mainClass;

	@Mock
	DatabaseDAO dependentClassOne;

	@Mock
	NetworkDAO dependentClassTwo;

	@Before
	public void init() {
		MockitoAnnotations.openMocks(this);
	}

	@Test
	public void validateTest()
	{
                //record expectations with mock methods
                when(dependentClassOne.save()).thenReturn(true);
                when(dependentClassTwo.save()).thenReturn(true);

		boolean saved = mainClass.save("temp.txt");
		assertEquals(true, saved);

                //verify recorded expectations
	}
}
```
### 10. What is the stubbing?
- A method stub or simply stub in software development is a piece of code used to stand in for some other programming functionality. A stub may simulate the behavior of existing code (such as a procedure on a remote machine; such methods are often called mocks) or be a temporary substitute for yet-to-be-developed code.
- The stubbing approach is easy to use and involves no extra dependencies for the unit test. The basic technique is to implement the collaborators as concrete classes which only exhibit the small part of the overall behaviour of the collaborator which is needed by the class under test.
- That is, a simple, fake implementation that conforms to the interface and is to be used for testing.
- Stubs provide canned answers to calls made during the test, usually not responding at all to anything outside what's programmed in for the test.
### 11. what is Mockito ArgumentMatchers
- Argument matchers are mainly used for performing flexible verification and stubbing in Mockito. It extends ArgumentMatchers class to access all the matcher functions. Mockito uses equal() as a legacy method for verification and matching of argument values. In some cases, we need more flexibility during the verification of argument values, so we should use argument matchers instead of equal() method. The ArgumentMatchers class is available in org.mockito package.
- Here, we are going to create an example of Argument matchers. We are using the anyInt() method in our test case, we can use any of the methods available in the ArgumentMatchers class.
```
import static org.junit.Assert.*;  
import static org.mockito.Mockito.when;  
import java.util.List;  
import org.junit.Test;  
import org.mockito.Mock;  
import org.mockito.Mockito;  
public class TestList {   
              @Test  
      public void testList_Argument_Matchers() {  
  
        List<String> mocklist = mock(List.class);  
  
        when(mocklist.get(Mockito.anyInt())).thenReturn("Mockito");  
          
        assertEquals("Mockito", mocklist.get(0));  
        assertEquals("Mockito", mocklist.get(1));   
                        assertEquals("Mockito", mocklist.get(2));  
    }  
 }  
```
### 12. what is Hamcrest Matchers
- Hamcrest is a popular framework that help us to create the matcher objects. It is used for writing software tests and also performs unit testing in Java programming language. Hamcrest is mainly used with other unit testing frameworks like JUnit, jMockit, Mockito, etc.
- The Hamcrest framework was designed to accommodate different types of unit testing frameworks. For example, Hamcrest can be used with TestNG and JUnit (all versions). The Hamcrest framework is also used with mocking frameworks such as JMock, EasyMock, and Mockito.

```
import static org.junit.Assert.*;  
import java.util.Arrays;  
import java.util.List;  
import static org.hamcrest.Matchers.*;  
import org.junit.Test;  
  
public class HamcrestMockito {  
  
    @Test  
    public void test() {  
          
        List<Integer> num = Arrays.asList(99,123,45,148,33);  
          
        assertThat( num, hasSize(5));  
        assertThat( num, hasItems(99,45));  
          
        assertThat( num, everyItem(greaterThan(20)));  
        assertThat( num, everyItem(greaterThanOrEqualTo(33)));  
        assertThat( num, everyItem(lessThan(150)));  
    }  
 }  
```
### 13. do you know @spy? what is difference between @spy and @Mock?
- Often you heard developers how to spy and mock in Mockito in unit test but what are the difference between spy and mock in Mockito API? Both can be used to mock methods or fields. The difference is that in mock, you are creating a complete mock or fake object while in spy, there is the real object and you just spying or stubbing specific methods of it.
- When using mock objects, the default behavior of the method when not stub is do nothing. Simple means, if its a void method, then it will do nothing when you call the method or if its a method with a return then it may return null, empty or the default value.
- While in spy objects, of course, since it is a real method, when you are not stubbing the method, then it will call the real method behavior. If you want to change and mock the method, then you need to stub it.
```
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.Spy;
import org.mockito.runners.MockitoJUnitRunner;
 
import java.util.ArrayList;
import java.util.List;
 
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.when;
 
@RunWith(MockitoJUnitRunner.class)
public class MockSpy {
 
    @Mock
    private List<String> mockList;
 
    @Spy
    private List<String> spyList = new ArrayList();
 
    @Test
    public void testMockList() {
        //by default, calling the methods of mock object will do nothing
        mockList.add("test");
        assertNull(mockList.get(0));
    }
 
    @Test
    public void testSpyList() {
        //spy object will call the real method when not stub
        spyList.add("test");
        assertEquals("test", spyList.get(0));
    }
 
    @Test
    public void testMockWithStub() {
        //try stubbing a method
        String expected = "Mock 100";
        when(mockList.get(100)).thenReturn(expected);
 
        assertEquals(expected, mockList.get(100));
    }
 
    @Test
    public void testSpyWithStub() {
        //stubbing a spy method will result the same as the mock object
        String expected = "Spy 100";
        //take note of using doReturn instead of when
        doReturn(expected).when(spyList).get(100);
 
        assertEquals(expected, spyList.get(100));
    }
}
```
- When shoud you use mock or spy? If you want to be safe and avoid calling external services and just want to test the logic inside of the unit, then use mock. If you want to call external service and perform calling of real dependency, or simply say, you want to run the program as it is and just stub specific methods, then use spy. So that’s the difference between spy and mock in mockito.
[Mockito interview questions](https://www.softwaretestinghelp.com/mockito-inteview-questions/)